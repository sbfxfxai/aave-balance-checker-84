"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIsInvalidBatchReceiver = exports.getBatchIsNativePayment = exports.getIsEmptyBatch = exports.getBatchSwapsCount = exports.getBatchRequiredActions = exports.encodeExchangeRouterMulticall = exports.buildCancelOrderMulticall = exports.buildUpdateOrderMulticall = exports.buildCreateOrderMulticall = exports.getBatchOrderMulticallPayload = exports.getExternalCallsPayload = exports.getEmptyExternalCallsPayload = exports.combineExternalCalls = exports.getBatchExternalCalls = exports.buildTokenTransfersParamsForIncreaseOrSwap = exports.buildTokenTransfersParamsForDecrease = exports.getBatchExternalSwapGasLimit = exports.getBatchTotalPayCollateralAmount = exports.getBatchTotalExecutionFee = exports.buildUpdateOrderPayload = exports.getIsTwapOrderPayload = exports.buildTwapOrdersPayloads = exports.buildDecreaseOrderPayload = exports.buildIncreaseOrderPayload = exports.buildSwapOrderPayload = void 0;
const uniq_1 = __importDefault(require("lodash/uniq"));
const viem_1 = require("viem");
const ExchangeRouter_1 = __importDefault(require("../abis/ExchangeRouter"));
const index_1 = require("../abis/index");
const Token_1 = __importDefault(require("../abis/Token"));
const chains_1 = require("../configs/chains");
const contracts_1 = require("../configs/contracts");
const tokens_1 = require("../configs/tokens");
const orders_1 = require("../types/orders");
const numbers_1 = require("./numbers");
const objects_1 = require("./objects");
const orders_2 = require("./orders");
const tokens_2 = require("./tokens");
const trade_1 = require("./trade");
const twap_1 = require("./twap");
const uiFeeReceiver_1 = require("./twap/uiFeeReceiver");
function buildSwapOrderPayload(p) {
    const tokenTransfersParams = buildTokenTransfersParamsForIncreaseOrSwap(p);
    const orderPayload = {
        addresses: {
            receiver: p.receiver,
            cancellationReceiver: viem_1.zeroAddress,
            callbackContract: viem_1.zeroAddress,
            uiFeeReceiver: p.uiFeeReceiver ?? viem_1.zeroAddress,
            market: viem_1.zeroAddress,
            initialCollateralToken: tokenTransfersParams.initialCollateralTokenAddress,
            swapPath: tokenTransfersParams.swapPath,
        },
        numbers: {
            sizeDeltaUsd: 0n,
            initialCollateralDeltaAmount: tokenTransfersParams.initialCollateralDeltaAmount,
            // triggerRatio of limit swaps is used in trade history
            triggerPrice: p.triggerRatio ?? 0n,
            acceptablePrice: 0n,
            executionFee: p.executionFeeAmount,
            callbackGasLimit: 0n,
            minOutputAmount: (0, trade_1.applySlippageToMinOut)(p.allowedSlippage, tokenTransfersParams.minOutputAmount),
            validFromTime: p.validFromTime ?? 0n,
        },
        orderType: p.orderType,
        decreasePositionSwapType: orders_1.DecreasePositionSwapType.NoSwap,
        isLong: false,
        shouldUnwrapNativeToken: tokenTransfersParams.isNativePayment || tokenTransfersParams.isNativeReceive,
        autoCancel: p.autoCancel,
        referralCode: p.referralCode ?? viem_1.zeroHash,
        dataList: [],
    };
    return {
        params: p,
        orderPayload,
        tokenTransfersParams,
    };
}
exports.buildSwapOrderPayload = buildSwapOrderPayload;
function buildIncreaseOrderPayload(p) {
    const tokenTransfersParams = buildTokenTransfersParamsForIncreaseOrSwap({
        ...p,
        minOutputAmount: 0n,
        receiveTokenAddress: undefined,
    });
    const indexToken = (0, tokens_1.getToken)(p.chainId, p.indexTokenAddress);
    let acceptablePrice;
    if (p.acceptablePrice === numbers_1.MaxUint256) {
        acceptablePrice = numbers_1.MaxUint256;
    }
    else {
        acceptablePrice = (0, tokens_2.convertToContractPrice)((0, trade_1.applySlippageToPrice)(p.allowedSlippage, p.acceptablePrice, true, p.isLong), indexToken.decimals);
    }
    let triggerPrice;
    if (p.triggerPrice === numbers_1.MaxUint256) {
        triggerPrice = numbers_1.MaxUint256;
    }
    else {
        triggerPrice = (0, tokens_2.convertToContractPrice)(p.triggerPrice ?? 0n, indexToken.decimals);
    }
    const orderPayload = {
        addresses: {
            receiver: p.receiver,
            cancellationReceiver: viem_1.zeroAddress,
            callbackContract: viem_1.zeroAddress,
            uiFeeReceiver: p.uiFeeReceiver ?? viem_1.zeroAddress,
            market: p.marketAddress,
            initialCollateralToken: tokenTransfersParams.initialCollateralTokenAddress,
            swapPath: tokenTransfersParams.swapPath,
        },
        numbers: {
            sizeDeltaUsd: p.sizeDeltaUsd,
            initialCollateralDeltaAmount: tokenTransfersParams.initialCollateralDeltaAmount,
            triggerPrice,
            acceptablePrice,
            executionFee: p.executionFeeAmount,
            callbackGasLimit: 0n,
            minOutputAmount: (0, trade_1.applySlippageToMinOut)(p.allowedSlippage, tokenTransfersParams.minOutputAmount),
            validFromTime: p.validFromTime ?? 0n,
        },
        orderType: p.orderType,
        decreasePositionSwapType: orders_1.DecreasePositionSwapType.NoSwap,
        isLong: p.isLong,
        shouldUnwrapNativeToken: tokenTransfersParams.isNativePayment,
        autoCancel: p.autoCancel,
        referralCode: p.referralCode ?? viem_1.zeroHash,
        dataList: [],
    };
    return {
        params: p,
        orderPayload,
        tokenTransfersParams,
    };
}
exports.buildIncreaseOrderPayload = buildIncreaseOrderPayload;
function buildDecreaseOrderPayload(p) {
    const indexToken = (0, tokens_1.getToken)(p.chainId, p.indexTokenAddress);
    const tokenTransfersParams = buildTokenTransfersParamsForDecrease(p);
    let acceptablePrice;
    if (p.acceptablePrice === numbers_1.MaxUint256) {
        acceptablePrice = numbers_1.MaxUint256;
    }
    else {
        acceptablePrice = (0, tokens_2.convertToContractPrice)((0, trade_1.applySlippageToPrice)(p.allowedSlippage, p.acceptablePrice, false, p.isLong), indexToken.decimals);
    }
    let triggerPrice;
    if (p.triggerPrice === numbers_1.MaxUint256) {
        triggerPrice = numbers_1.MaxUint256;
    }
    else {
        triggerPrice = (0, tokens_2.convertToContractPrice)(p.triggerPrice ?? 0n, indexToken.decimals);
    }
    const orderPayload = {
        addresses: {
            receiver: p.receiver,
            cancellationReceiver: viem_1.zeroAddress,
            callbackContract: viem_1.zeroAddress,
            uiFeeReceiver: p.uiFeeReceiver ?? viem_1.zeroAddress,
            market: p.marketAddress,
            initialCollateralToken: tokenTransfersParams.initialCollateralTokenAddress,
            swapPath: tokenTransfersParams.swapPath,
        },
        numbers: {
            sizeDeltaUsd: p.sizeDeltaUsd,
            initialCollateralDeltaAmount: tokenTransfersParams.initialCollateralDeltaAmount,
            triggerPrice,
            acceptablePrice,
            executionFee: p.executionFeeAmount,
            callbackGasLimit: 0n,
            minOutputAmount: (0, trade_1.applySlippageToMinOut)(p.allowedSlippage, tokenTransfersParams.minOutputAmount),
            validFromTime: p.validFromTime ?? 0n,
        },
        orderType: p.orderType,
        decreasePositionSwapType: p.decreasePositionSwapType,
        isLong: p.isLong,
        shouldUnwrapNativeToken: p.receiveTokenAddress === tokens_1.NATIVE_TOKEN_ADDRESS,
        autoCancel: p.autoCancel,
        referralCode: p.referralCode ?? viem_1.zeroHash,
        dataList: [],
    };
    return {
        params: p,
        orderPayload,
        tokenTransfersParams,
    };
}
exports.buildDecreaseOrderPayload = buildDecreaseOrderPayload;
function buildTwapOrdersPayloads(p, twapParams) {
    const uiFeeReceiver = (0, uiFeeReceiver_1.createTwapUiFeeReceiver)({ numberOfParts: twapParams.numberOfParts });
    if ((0, orders_2.isSwapOrderType)(p.orderType)) {
        return Array.from({ length: twapParams.numberOfParts }, (_, i) => {
            const params = p;
            return buildSwapOrderPayload({
                chainId: params.chainId,
                receiver: params.receiver,
                executionGasLimit: params.executionGasLimit,
                payTokenAddress: params.payTokenAddress,
                receiveTokenAddress: params.receiveTokenAddress,
                swapPath: params.swapPath,
                externalSwapQuote: undefined,
                minOutputAmount: 0n,
                triggerRatio: params.triggerRatio,
                referralCode: params.referralCode,
                autoCancel: params.autoCancel,
                allowedSlippage: 0,
                ...(params.expectedOutputAmount !== undefined && {
                    expectedOutputAmount: params.expectedOutputAmount / BigInt(twapParams.numberOfParts),
                }),
                payTokenAmount: params.payTokenAmount / BigInt(twapParams.numberOfParts),
                executionFeeAmount: params.executionFeeAmount / BigInt(twapParams.numberOfParts),
                validFromTime: (0, twap_1.getTwapValidFromTime)(twapParams.duration, twapParams.numberOfParts, i),
                orderType: orders_1.OrderType.LimitSwap,
                uiFeeReceiver,
            });
        });
    }
    if ((0, orders_2.isIncreaseOrderType)(p.orderType)) {
        return Array.from({ length: twapParams.numberOfParts }, (_, i) => {
            const params = p;
            const acceptablePrice = params.isLong ? numbers_1.MaxUint256 : 0n;
            const triggerPrice = acceptablePrice;
            return buildIncreaseOrderPayload({
                chainId: params.chainId,
                receiver: params.receiver,
                executionGasLimit: params.executionGasLimit,
                referralCode: params.referralCode,
                autoCancel: params.autoCancel,
                swapPath: params.swapPath,
                externalSwapQuote: undefined,
                marketAddress: params.marketAddress,
                indexTokenAddress: params.indexTokenAddress,
                isLong: params.isLong,
                sizeDeltaUsd: params.sizeDeltaUsd / BigInt(twapParams.numberOfParts),
                sizeDeltaInTokens: params.sizeDeltaInTokens / BigInt(twapParams.numberOfParts),
                payTokenAddress: params.payTokenAddress,
                allowedSlippage: 0,
                payTokenAmount: params.payTokenAmount / BigInt(twapParams.numberOfParts),
                collateralTokenAddress: params.collateralTokenAddress,
                collateralDeltaAmount: params.collateralDeltaAmount / BigInt(twapParams.numberOfParts),
                executionFeeAmount: params.executionFeeAmount / BigInt(twapParams.numberOfParts),
                validFromTime: (0, twap_1.getTwapValidFromTime)(twapParams.duration, twapParams.numberOfParts, i),
                orderType: orders_1.OrderType.LimitIncrease,
                acceptablePrice,
                triggerPrice,
                uiFeeReceiver,
            });
        });
    }
    return Array.from({ length: twapParams.numberOfParts }, (_, i) => {
        const params = p;
        const acceptablePrice = !params.isLong ? numbers_1.MaxUint256 : 0n;
        const triggerPrice = acceptablePrice;
        return buildDecreaseOrderPayload({
            chainId: params.chainId,
            receiver: params.receiver,
            executionGasLimit: params.executionGasLimit,
            referralCode: params.referralCode,
            autoCancel: params.autoCancel,
            swapPath: params.swapPath,
            externalSwapQuote: undefined,
            marketAddress: params.marketAddress,
            indexTokenAddress: params.indexTokenAddress,
            isLong: params.isLong,
            collateralTokenAddress: params.collateralTokenAddress,
            collateralDeltaAmount: params.collateralDeltaAmount / BigInt(twapParams.numberOfParts),
            sizeDeltaUsd: params.sizeDeltaUsd / BigInt(twapParams.numberOfParts),
            sizeDeltaInTokens: params.sizeDeltaInTokens / BigInt(twapParams.numberOfParts),
            executionFeeAmount: params.executionFeeAmount / BigInt(twapParams.numberOfParts),
            validFromTime: (0, twap_1.getTwapValidFromTime)(twapParams.duration, twapParams.numberOfParts, i),
            orderType: orders_1.OrderType.LimitDecrease,
            acceptablePrice,
            triggerPrice,
            allowedSlippage: 0,
            uiFeeReceiver,
            minOutputUsd: params.minOutputUsd / BigInt(twapParams.numberOfParts),
            receiveTokenAddress: params.receiveTokenAddress,
            decreasePositionSwapType: params.decreasePositionSwapType,
        });
    });
}
exports.buildTwapOrdersPayloads = buildTwapOrdersPayloads;
function getIsTwapOrderPayload(p) {
    return p.numbers.validFromTime !== 0n;
}
exports.getIsTwapOrderPayload = getIsTwapOrderPayload;
function buildUpdateOrderPayload(p) {
    const indexToken = (0, tokens_1.getToken)(p.chainId, p.indexTokenAddress);
    return {
        params: p,
        updatePayload: {
            orderKey: p.orderKey,
            sizeDeltaUsd: p.sizeDeltaUsd,
            triggerPrice: (0, orders_2.isSwapOrderType)(p.orderType)
                ? p.triggerPrice
                : (0, tokens_2.convertToContractPrice)(p.triggerPrice, indexToken.decimals),
            acceptablePrice: (0, tokens_2.convertToContractPrice)(p.acceptablePrice, indexToken.decimals),
            minOutputAmount: p.minOutputAmount,
            autoCancel: p.autoCancel,
            validFromTime: 0n,
            executionFeeTopUp: p.executionFeeTopUp,
        },
    };
}
exports.buildUpdateOrderPayload = buildUpdateOrderPayload;
function getBatchTotalExecutionFee({ batchParams: { createOrderParams, updateOrderParams }, tokensData, chainId, }) {
    let feeTokenAmount = 0n;
    let gasLimit = 0n;
    const wnt = (0, objects_1.getByKey)(tokensData, (0, tokens_1.getWrappedToken)(chainId).address);
    if (!wnt) {
        return undefined;
    }
    for (const co of createOrderParams) {
        feeTokenAmount += co.orderPayload.numbers.executionFee;
        gasLimit += co.params.executionGasLimit;
    }
    for (const uo of updateOrderParams) {
        feeTokenAmount += uo.updatePayload.executionFeeTopUp;
    }
    const feeUsd = (0, tokens_2.convertToUsd)(feeTokenAmount, wnt.decimals, wnt.prices.maxPrice);
    const isFeeHigh = feeUsd > (0, numbers_1.expandDecimals)((0, chains_1.getHighExecutionFee)(chainId), numbers_1.USD_DECIMALS);
    const isFeeVeryHigh = feeUsd > (0, numbers_1.expandDecimals)((0, chains_1.getExcessiveExecutionFee)(chainId), numbers_1.USD_DECIMALS);
    return {
        feeTokenAmount,
        gasLimit,
        feeUsd,
        feeToken: wnt,
        isFeeHigh,
        isFeeVeryHigh,
    };
}
exports.getBatchTotalExecutionFee = getBatchTotalExecutionFee;
function getBatchTotalPayCollateralAmount(batchParams) {
    const payAmounts = {};
    for (const co of batchParams.createOrderParams) {
        const payTokenAddress = co.tokenTransfersParams?.payTokenAddress;
        const payTokenAmount = co.tokenTransfersParams?.payTokenAmount;
        if (payTokenAddress && payTokenAmount) {
            payAmounts[payTokenAddress] = (payAmounts[payTokenAddress] ?? 0n) + payTokenAmount;
        }
    }
    return payAmounts;
}
exports.getBatchTotalPayCollateralAmount = getBatchTotalPayCollateralAmount;
function getBatchExternalSwapGasLimit(batchParams) {
    return batchParams.createOrderParams.reduce((acc, co) => {
        const externalSwapQuote = co.params.externalSwapQuote;
        if (externalSwapQuote) {
            return acc + externalSwapQuote.txnData.estimatedGas;
        }
        return acc;
    }, 0n);
}
exports.getBatchExternalSwapGasLimit = getBatchExternalSwapGasLimit;
function buildTokenTransfersParamsForDecrease({ chainId, executionFeeAmount, collateralTokenAddress, collateralDeltaAmount, swapPath, minOutputUsd, receiveTokenAddress, }) {
    const orderVaultAddress = (0, contracts_1.getContract)(chainId, "OrderVault");
    const { tokenTransfers, value } = combineTransfers([
        {
            tokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
            destination: orderVaultAddress,
            amount: executionFeeAmount,
        },
    ]);
    return {
        isNativePayment: false,
        isNativeReceive: receiveTokenAddress === tokens_1.NATIVE_TOKEN_ADDRESS,
        initialCollateralTokenAddress: (0, tokens_1.convertTokenAddress)(chainId, collateralTokenAddress, "wrapped"),
        initialCollateralDeltaAmount: collateralDeltaAmount,
        tokenTransfers,
        payTokenAddress: viem_1.zeroAddress,
        payTokenAmount: 0n,
        minOutputAmount: minOutputUsd,
        swapPath,
        value,
        externalCalls: undefined,
    };
}
exports.buildTokenTransfersParamsForDecrease = buildTokenTransfersParamsForDecrease;
function buildTokenTransfersParamsForIncreaseOrSwap({ chainId, receiver, payTokenAddress, payTokenAmount, receiveTokenAddress, executionFeeAmount, externalSwapQuote, minOutputAmount, swapPath, }) {
    const isNativePayment = payTokenAddress === tokens_1.NATIVE_TOKEN_ADDRESS;
    const isNativeReceive = receiveTokenAddress === tokens_1.NATIVE_TOKEN_ADDRESS;
    const orderVaultAddress = (0, contracts_1.getContract)(chainId, "OrderVault");
    const externalHandlerAddress = (0, contracts_1.getContract)(chainId, "ExternalHandler");
    let finalPayTokenAmount = payTokenAmount;
    const { tokenTransfers, value } = combineTransfers([
        {
            tokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
            destination: orderVaultAddress,
            amount: executionFeeAmount,
        },
        {
            tokenAddress: payTokenAddress,
            destination: externalSwapQuote ? externalHandlerAddress : orderVaultAddress,
            amount: payTokenAmount,
        },
    ]);
    let initialCollateralTokenAddress = (0, tokens_1.convertTokenAddress)(chainId, payTokenAddress, "wrapped");
    let initialCollateralDeltaAmount = payTokenAmount;
    let externalCalls;
    if (externalSwapQuote && receiver) {
        /**
         * External swap will be executed before order creation logic,
         * so the final order has no swap parameters and must treat the outToken address as an initial collateral
         * */
        initialCollateralTokenAddress = (0, tokens_1.convertTokenAddress)(chainId, externalSwapQuote.outTokenAddress, "wrapped");
        initialCollateralDeltaAmount = 0n;
        externalCalls = getExternalCallsPayload({
            chainId,
            account: receiver,
            quote: externalSwapQuote,
        });
        finalPayTokenAmount = externalSwapQuote.amountIn;
    }
    return {
        isNativePayment,
        isNativeReceive,
        initialCollateralTokenAddress,
        initialCollateralDeltaAmount,
        tokenTransfers,
        payTokenAddress,
        payTokenAmount: finalPayTokenAmount,
        minOutputAmount,
        swapPath,
        value,
        externalCalls,
    };
}
exports.buildTokenTransfersParamsForIncreaseOrSwap = buildTokenTransfersParamsForIncreaseOrSwap;
function getBatchExternalCalls(batchParams) {
    const externalCalls = [];
    for (const createOrderParams of batchParams.createOrderParams) {
        if (createOrderParams.tokenTransfersParams?.externalCalls) {
            externalCalls.push(createOrderParams.tokenTransfersParams.externalCalls);
        }
    }
    return combineExternalCalls(externalCalls);
}
exports.getBatchExternalCalls = getBatchExternalCalls;
function combineExternalCalls(externalCalls) {
    const sendTokensMap = {};
    const refundTokensMap = {};
    const externalCallTargets = [];
    const externalCallDataList = [];
    for (const call of externalCalls) {
        for (const [index, tokenAddress] of call.sendTokens.entries()) {
            sendTokensMap[tokenAddress] = (sendTokensMap[tokenAddress] ?? 0n) + call.sendAmounts[index];
        }
        for (const [index, tokenAddress] of call.refundTokens.entries()) {
            refundTokensMap[tokenAddress] = call.refundReceivers[index];
        }
        externalCallTargets.push(...call.externalCallTargets);
        externalCallDataList.push(...call.externalCallDataList);
    }
    return {
        sendTokens: Object.keys(sendTokensMap),
        sendAmounts: Object.values(sendTokensMap),
        externalCallTargets,
        externalCallDataList,
        refundReceivers: Object.values(refundTokensMap),
        refundTokens: Object.keys(refundTokensMap),
    };
}
exports.combineExternalCalls = combineExternalCalls;
function getEmptyExternalCallsPayload() {
    return {
        sendTokens: [],
        sendAmounts: [],
        externalCallTargets: [],
        externalCallDataList: [],
        refundReceivers: [],
        refundTokens: [],
    };
}
exports.getEmptyExternalCallsPayload = getEmptyExternalCallsPayload;
function getExternalCallsPayload({ chainId, account, quote, }) {
    const inTokenAddress = (0, tokens_1.convertTokenAddress)(chainId, quote.inTokenAddress, "wrapped");
    const outTokenAddress = (0, tokens_1.convertTokenAddress)(chainId, quote.outTokenAddress, "wrapped");
    const wntAddress = (0, tokens_1.getWrappedToken)(chainId).address;
    const refundTokens = (0, uniq_1.default)([inTokenAddress, outTokenAddress, wntAddress]);
    const payload = {
        sendTokens: [inTokenAddress],
        sendAmounts: [quote.amountIn],
        externalCallTargets: [],
        externalCallDataList: [],
        refundTokens,
        refundReceivers: Array.from({ length: refundTokens.length }, () => account),
    };
    if (quote.needSpenderApproval) {
        payload.externalCallTargets.push(inTokenAddress);
        payload.externalCallDataList.push((0, viem_1.encodeFunctionData)({
            abi: Token_1.default,
            functionName: "approve",
            args: [quote.txnData.to, numbers_1.MaxUint256],
        }));
    }
    payload.externalCallTargets.push(quote.txnData.to);
    payload.externalCallDataList.push(quote.txnData.data);
    return payload;
}
exports.getExternalCallsPayload = getExternalCallsPayload;
function combineTransfers(tokenTransfers) {
    const transfersMap = {};
    let value = 0n;
    for (const transfer of tokenTransfers) {
        const key = `${transfer.tokenAddress}:${transfer.destination}`;
        if (!transfersMap[key]) {
            transfersMap[key] = { ...transfer };
        }
        else {
            transfersMap[key].amount += transfer.amount;
        }
        if (transfer.tokenAddress === tokens_1.NATIVE_TOKEN_ADDRESS) {
            value += transfer.amount;
        }
    }
    return { tokenTransfers: Object.values(transfersMap), value };
}
function getBatchOrderMulticallPayload({ params }) {
    const { createOrderParams, updateOrderParams, cancelOrderParams } = params;
    const multicall = [];
    let value = 0n;
    for (const params of createOrderParams) {
        const { multicall: createMulticall, value: createValue } = buildCreateOrderMulticall(params);
        multicall.push(...createMulticall);
        value += createValue;
    }
    for (const update of updateOrderParams) {
        const { multicall: updateMulticall, value: updateValue } = buildUpdateOrderMulticall(update);
        multicall.push(...updateMulticall);
        value += updateValue;
    }
    for (const cancel of cancelOrderParams) {
        const { multicall: cancelMulticall, value: cancelValue } = buildCancelOrderMulticall({ params: cancel });
        multicall.push(...cancelMulticall);
        value += cancelValue;
    }
    const { encodedMulticall, callData } = encodeExchangeRouterMulticall(multicall);
    return { multicall, value, encodedMulticall, callData };
}
exports.getBatchOrderMulticallPayload = getBatchOrderMulticallPayload;
function buildCreateOrderMulticall(params) {
    const { tokenTransfersParams, orderPayload } = params;
    const { tokenTransfers = [], value = 0n, externalCalls = undefined } = tokenTransfersParams ?? {};
    const multicall = [];
    for (const transfer of tokenTransfers) {
        if (transfer.tokenAddress === tokens_1.NATIVE_TOKEN_ADDRESS) {
            multicall.push({ method: "sendWnt", params: [transfer.destination, transfer.amount] });
        }
        else {
            multicall.push({ method: "sendTokens", params: [transfer.tokenAddress, transfer.destination, transfer.amount] });
        }
    }
    if (externalCalls) {
        multicall.push({
            method: "makeExternalCalls",
            params: [
                externalCalls.externalCallTargets,
                externalCalls.externalCallDataList,
                externalCalls.refundTokens,
                externalCalls.refundReceivers,
            ],
        });
    }
    multicall.push({
        method: "createOrder",
        params: [orderPayload],
    });
    return {
        multicall,
        value,
    };
}
exports.buildCreateOrderMulticall = buildCreateOrderMulticall;
function buildUpdateOrderMulticall(updateTxn) {
    const { updatePayload, params: updateParams } = updateTxn;
    const { chainId } = updateParams;
    const orderVaultAddress = (0, contracts_1.getContract)(chainId, "OrderVault");
    const multicall = [];
    if (updatePayload.executionFeeTopUp > 0n) {
        multicall.push({ method: "sendWnt", params: [orderVaultAddress, updatePayload.executionFeeTopUp] });
    }
    multicall.push({
        method: "updateOrder",
        params: [
            updatePayload.orderKey,
            updatePayload.sizeDeltaUsd,
            updatePayload.acceptablePrice,
            updatePayload.triggerPrice,
            updatePayload.minOutputAmount,
            0n,
            updatePayload.autoCancel,
        ],
    });
    return {
        multicall,
        value: updatePayload.executionFeeTopUp,
    };
}
exports.buildUpdateOrderMulticall = buildUpdateOrderMulticall;
function buildCancelOrderMulticall({ params }) {
    const { orderKey } = params;
    const multicall = [];
    multicall.push({
        method: "cancelOrder",
        params: [orderKey],
    });
    return {
        multicall,
        value: 0n,
    };
}
exports.buildCancelOrderMulticall = buildCancelOrderMulticall;
function encodeExchangeRouterMulticall(multicall) {
    const encodedMulticall = multicall.map((call) => (0, viem_1.encodeFunctionData)({
        abi: index_1.abis.ExchangeRouter,
        functionName: call.method,
        args: call.params,
    }));
    const callData = (0, viem_1.encodeFunctionData)({
        abi: ExchangeRouter_1.default,
        functionName: "multicall",
        args: [encodedMulticall],
    });
    return {
        encodedMulticall,
        callData,
    };
}
exports.encodeExchangeRouterMulticall = encodeExchangeRouterMulticall;
function getBatchRequiredActions(orderParams) {
    if (!orderParams) {
        return 0;
    }
    return (orderParams.createOrderParams.length + orderParams.updateOrderParams.length + orderParams.cancelOrderParams.length);
}
exports.getBatchRequiredActions = getBatchRequiredActions;
function getBatchSwapsCount(orderParams) {
    if (!orderParams) {
        return 0;
    }
    return orderParams.createOrderParams.reduce((acc, co) => {
        return acc + co.orderPayload.addresses.swapPath.length;
    }, 0);
}
exports.getBatchSwapsCount = getBatchSwapsCount;
function getIsEmptyBatch(orderParams) {
    if (!orderParams) {
        return true;
    }
    if (getBatchRequiredActions(orderParams) === 0) {
        return true;
    }
    const hasEmptyOrder = orderParams.createOrderParams.some((o) => o.orderPayload.numbers.sizeDeltaUsd === 0n && o.orderPayload.numbers.initialCollateralDeltaAmount === 0n);
    return hasEmptyOrder;
}
exports.getIsEmptyBatch = getIsEmptyBatch;
function getBatchIsNativePayment(orderParams) {
    return orderParams.createOrderParams.some((o) => o.tokenTransfersParams?.isNativePayment);
}
exports.getBatchIsNativePayment = getBatchIsNativePayment;
function getIsInvalidBatchReceiver(batchParams, signerAddress) {
    return batchParams.createOrderParams.some((co) => co.orderPayload.addresses.receiver !== signerAddress);
}
exports.getIsInvalidBatchReceiver = getIsInvalidBatchReceiver;
