"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSwapPathComparator = exports.getSwapAmountsByToValue = exports.getSwapAmountsByFromValue = void 0;
const factors_1 = require("../../configs/factors");
const bigmath_1 = require("../bigmath");
const fees_1 = require("../fees");
const numbers_1 = require("../numbers");
const tokens_1 = require("../tokens");
const buildSwapStrategy_1 = require("./buildSwapStrategy");
function getSwapAmountsByFromValue(p) {
    const { tokenIn, tokenOut, amountIn, triggerRatio, isLimit, swapOptimizationOrder, uiFeeFactor, allowedSwapSlippageBps, marketsInfoData, chainId, externalSwapQuoteParams, } = p;
    if (!externalSwapQuoteParams) {
        return getSwapAmountsByFromValueDefault(p);
    }
    const swapStrategy = (0, buildSwapStrategy_1.buildSwapStrategy)({
        amountIn,
        tokenIn,
        tokenOut,
        marketsInfoData,
        chainId,
        swapOptimizationOrder,
        externalSwapQuoteParams,
    });
    const swapPathStats = swapStrategy.swapPathStats;
    const totalSwapVolume = (0, fees_1.getTotalSwapVolumeFromSwapStats)(swapPathStats?.swapSteps);
    const swapUiFeeUsd = (0, numbers_1.applyFactor)(totalSwapVolume, uiFeeFactor);
    const swapUiFeeAmount = (0, tokens_1.convertToTokenAmount)(swapUiFeeUsd, tokenOut.decimals, swapStrategy.priceOut);
    const defaultAmounts = {
        amountIn,
        usdIn: swapStrategy.usdIn,
        amountOut: swapStrategy.amountOut,
        usdOut: swapStrategy.usdOut,
        minOutputAmount: swapStrategy.amountOut,
        priceIn: swapStrategy.priceIn,
        priceOut: swapStrategy.priceOut,
        swapStrategy,
    };
    let amountOut = swapStrategy.amountOut;
    let usdOut = swapStrategy.usdOut;
    let minOutputAmount = 0n;
    if (isLimit) {
        if (!triggerRatio) {
            return defaultAmounts;
        }
        amountOut = (0, tokens_1.getAmountByRatio)({
            fromToken: tokenIn,
            toToken: tokenOut,
            fromTokenAmount: amountIn,
            ratio: triggerRatio.ratio,
            shouldInvertRatio: triggerRatio.largestToken.address === tokenOut.address,
            allowedSwapSlippageBps,
        });
        usdOut = (0, tokens_1.convertToUsd)(amountOut, tokenOut.decimals, swapStrategy.priceOut);
        amountOut = (0, tokens_1.convertToTokenAmount)(usdOut, tokenOut.decimals, swapStrategy.priceOut);
        minOutputAmount = amountOut;
    }
    else {
        usdOut = swapStrategy.usdOut - swapUiFeeUsd;
        amountOut = swapStrategy.amountOut - swapUiFeeAmount;
        minOutputAmount = amountOut;
    }
    if (amountOut < 0) {
        amountOut = 0n;
        usdOut = 0n;
        minOutputAmount = 0n;
    }
    return {
        amountIn,
        usdIn: swapStrategy.usdIn,
        amountOut,
        usdOut,
        priceIn: swapStrategy.priceIn,
        priceOut: swapStrategy.priceOut,
        minOutputAmount,
        swapStrategy,
    };
}
exports.getSwapAmountsByFromValue = getSwapAmountsByFromValue;
function getSwapAmountsByToValue(p) {
    const { tokenIn, tokenOut, amountOut, triggerRatio, isLimit, uiFeeFactor, swapOptimizationOrder, allowedSwapSlippageBps, marketsInfoData, chainId, externalSwapQuoteParams, } = p;
    if (!externalSwapQuoteParams) {
        return getSwapAmountsByToValueDefault(p);
    }
    const swapStrategyReverse = (0, buildSwapStrategy_1.buildReverseSwapStrategy)({
        amountOut,
        tokenIn,
        tokenOut,
        marketsInfoData,
        chainId,
        externalSwapQuoteParams,
        swapOptimizationOrder,
    });
    const swapStrategy = (0, buildSwapStrategy_1.buildSwapStrategy)({
        amountIn: swapStrategyReverse.amountIn,
        tokenIn,
        tokenOut,
        marketsInfoData,
        chainId,
        swapOptimizationOrder,
        externalSwapQuoteParams,
    });
    const uiFeeUsd = (0, numbers_1.applyFactor)(swapStrategy.usdIn, uiFeeFactor);
    const defaultAmounts = {
        amountIn: swapStrategy.amountIn,
        usdIn: swapStrategy.usdIn,
        amountOut: swapStrategy.amountOut,
        usdOut: swapStrategy.usdOut,
        minOutputAmount: swapStrategy.amountOut,
        priceIn: swapStrategy.priceIn,
        priceOut: swapStrategy.priceOut,
        swapStrategy,
    };
    if (!swapStrategy.swapPathStats) {
        return defaultAmounts;
    }
    let amountIn = swapStrategy.amountIn;
    let usdIn = swapStrategy.usdIn;
    if (isLimit) {
        if (!triggerRatio) {
            return defaultAmounts;
        }
        amountIn = (0, tokens_1.getAmountByRatio)({
            fromToken: tokenOut,
            toToken: tokenIn,
            fromTokenAmount: amountOut,
            ratio: triggerRatio.ratio,
            shouldInvertRatio: triggerRatio.largestToken.address === tokenIn.address,
        });
        usdIn = (0, tokens_1.convertToUsd)(amountIn, tokenIn.decimals, swapStrategy.priceIn);
        if (allowedSwapSlippageBps !== undefined) {
            usdIn += bigmath_1.bigMath.mulDiv(usdIn, allowedSwapSlippageBps ?? 0n, factors_1.BASIS_POINTS_DIVISOR_BIGINT);
        }
        amountIn = (0, tokens_1.convertToTokenAmount)(usdIn, tokenIn.decimals, swapStrategy.priceIn);
    }
    else {
        usdIn = swapStrategy.usdIn + uiFeeUsd;
        amountIn = (0, tokens_1.convertToTokenAmount)(usdIn, tokenIn.decimals, swapStrategy.priceIn);
    }
    let minOutputAmount = amountOut;
    if (amountIn < 0) {
        amountIn = 0n;
        usdIn = 0n;
        minOutputAmount = 0n;
    }
    return {
        amountIn,
        amountOut: swapStrategy.amountOut,
        usdIn: swapStrategy.usdIn,
        minOutputAmount,
        usdOut: swapStrategy.usdOut,
        priceIn: swapStrategy.priceIn,
        priceOut: swapStrategy.priceOut,
        swapStrategy: swapStrategy,
    };
}
exports.getSwapAmountsByToValue = getSwapAmountsByToValue;
function getSwapAmountsByFromValueDefault(p) {
    const { tokenIn, tokenOut, amountIn, triggerRatio, isLimit, swapOptimizationOrder, findSwapPath, uiFeeFactor, allowedSwapSlippageBps, } = p;
    const priceIn = tokenIn.prices.minPrice;
    const priceOut = tokenOut.prices.maxPrice;
    const usdIn = (0, tokens_1.convertToUsd)(amountIn, tokenIn.decimals, priceIn);
    let amountOut = 0n;
    let usdOut = 0n;
    let minOutputAmount = 0n;
    const defaultSwapStrategy = {
        type: "noSwap",
        externalSwapQuote: undefined,
        swapPathStats: undefined,
        amountIn,
        amountOut,
        usdIn,
        usdOut,
        priceIn,
        priceOut,
        feesUsd: 0n,
    };
    const defaultAmounts = {
        amountIn,
        usdIn,
        amountOut,
        usdOut,
        minOutputAmount,
        priceIn,
        priceOut,
        swapStrategy: defaultSwapStrategy,
    };
    if (amountIn <= 0) {
        return defaultAmounts;
    }
    if ((0, tokens_1.getIsEquivalentTokens)(tokenIn, tokenOut)) {
        amountOut = amountIn;
        usdOut = usdIn;
        minOutputAmount = amountOut;
        const swapStrategy = {
            type: "noSwap",
            externalSwapQuote: undefined,
            swapPathStats: undefined,
            amountIn,
            amountOut,
            usdIn,
            usdOut,
            priceIn,
            priceOut,
            feesUsd: 0n,
        };
        return {
            amountIn,
            usdIn,
            amountOut,
            usdOut,
            minOutputAmount,
            priceIn,
            priceOut,
            swapStrategy,
        };
    }
    if ((0, tokens_1.getIsStake)(tokenIn, tokenOut) || (0, tokens_1.getIsUnstake)(tokenIn, tokenOut)) {
        return getPlainSwapAmountsByFromToken(tokenIn, tokenOut, amountIn);
    }
    const swapPathStats = findSwapPath(defaultAmounts.usdIn, { order: swapOptimizationOrder });
    const totalSwapVolume = (0, fees_1.getTotalSwapVolumeFromSwapStats)(swapPathStats?.swapSteps);
    const swapUiFeeUsd = (0, numbers_1.applyFactor)(totalSwapVolume, uiFeeFactor);
    const swapUiFeeAmount = (0, tokens_1.convertToTokenAmount)(swapUiFeeUsd, tokenOut.decimals, priceOut);
    if (!swapPathStats) {
        return defaultAmounts;
    }
    if (isLimit) {
        if (!triggerRatio) {
            return defaultAmounts;
        }
        amountOut = (0, tokens_1.getAmountByRatio)({
            fromToken: tokenIn,
            toToken: tokenOut,
            fromTokenAmount: amountIn,
            ratio: triggerRatio.ratio,
            shouldInvertRatio: triggerRatio.largestToken.address === tokenOut.address,
            allowedSwapSlippageBps,
        });
        usdOut = (0, tokens_1.convertToUsd)(amountOut, tokenOut.decimals, priceOut);
        amountOut = (0, tokens_1.convertToTokenAmount)(usdOut, tokenOut.decimals, priceOut);
        minOutputAmount = amountOut;
    }
    else {
        usdOut = swapPathStats.usdOut - swapUiFeeUsd;
        amountOut = swapPathStats.amountOut - swapUiFeeAmount;
        minOutputAmount = amountOut;
    }
    if (amountOut < 0) {
        amountOut = 0n;
        usdOut = 0n;
        minOutputAmount = 0n;
    }
    const swapStrategy = {
        type: "internalSwap",
        externalSwapQuote: undefined,
        swapPathStats,
        amountIn,
        amountOut,
        usdIn,
        usdOut,
        priceIn,
        priceOut,
        feesUsd: usdIn - usdOut,
    };
    return {
        amountIn,
        usdIn,
        amountOut,
        usdOut,
        priceIn,
        priceOut,
        minOutputAmount,
        swapStrategy,
    };
}
function getSwapAmountsByToValueDefault(p) {
    const { tokenIn, tokenOut, amountOut, triggerRatio, isLimit, findSwapPath, uiFeeFactor, swapOptimizationOrder, allowedSwapSlippageBps, } = p;
    const priceIn = tokenIn.prices.minPrice;
    const priceOut = tokenOut.prices.maxPrice;
    const usdOut = (0, tokens_1.convertToUsd)(amountOut, tokenOut.decimals, priceOut);
    const uiFeeUsd = (0, numbers_1.applyFactor)(usdOut, uiFeeFactor);
    let minOutputAmount = amountOut;
    let amountIn = 0n;
    let usdIn = 0n;
    const defaultSwapStrategy = {
        type: "noSwap",
        externalSwapQuote: undefined,
        swapPathStats: undefined,
        amountIn,
        amountOut,
        usdIn,
        usdOut,
        priceIn,
        priceOut,
        feesUsd: 0n,
    };
    const defaultAmounts = {
        amountIn,
        usdIn,
        amountOut,
        usdOut,
        minOutputAmount,
        priceIn,
        priceOut,
        swapStrategy: defaultSwapStrategy,
    };
    if (amountOut <= 0) {
        return defaultAmounts;
    }
    if ((0, tokens_1.getIsEquivalentTokens)(tokenIn, tokenOut)) {
        amountIn = amountOut;
        usdIn = usdOut;
        const swapStrategy = {
            type: "noSwap",
            externalSwapQuote: undefined,
            swapPathStats: undefined,
            amountIn,
            amountOut,
            usdIn,
            usdOut,
            priceIn,
            priceOut,
            feesUsd: 0n,
        };
        return {
            amountIn,
            usdIn,
            amountOut,
            usdOut,
            minOutputAmount,
            priceIn,
            priceOut,
            swapStrategy,
        };
    }
    if ((0, tokens_1.getIsStake)(tokenIn, tokenOut) || (0, tokens_1.getIsUnstake)(tokenIn, tokenOut)) {
        return getPlainSwapAmountsByToToken(tokenIn, tokenOut, amountOut);
    }
    const baseUsdIn = usdOut;
    const swapPathStats = findSwapPath(baseUsdIn, { order: swapOptimizationOrder });
    if (!swapPathStats) {
        return defaultAmounts;
    }
    if (isLimit) {
        if (!triggerRatio) {
            return defaultAmounts;
        }
        amountIn = (0, tokens_1.getAmountByRatio)({
            fromToken: tokenOut,
            toToken: tokenIn,
            fromTokenAmount: amountOut,
            ratio: triggerRatio.ratio,
            shouldInvertRatio: triggerRatio.largestToken.address === tokenIn.address,
        });
        usdIn = (0, tokens_1.convertToUsd)(amountIn, tokenIn.decimals, priceIn);
        if (allowedSwapSlippageBps !== undefined) {
            usdIn += bigmath_1.bigMath.mulDiv(usdIn, allowedSwapSlippageBps ?? 0n, factors_1.BASIS_POINTS_DIVISOR_BIGINT);
        }
        amountIn = (0, tokens_1.convertToTokenAmount)(usdIn, tokenIn.decimals, priceIn);
    }
    else {
        const adjustedUsdIn = swapPathStats.usdOut > 0 ? bigmath_1.bigMath.mulDiv(baseUsdIn, usdOut, swapPathStats.usdOut) : 0n;
        usdIn = adjustedUsdIn + uiFeeUsd;
        amountIn = (0, tokens_1.convertToTokenAmount)(usdIn, tokenIn.decimals, priceIn);
    }
    if (amountIn < 0) {
        amountIn = 0n;
        usdIn = 0n;
    }
    const swapStrategy = {
        type: "internalSwap",
        externalSwapQuote: undefined,
        swapPathStats,
        amountIn,
        amountOut,
        usdIn,
        usdOut,
        priceIn,
        priceOut,
        feesUsd: usdIn - usdOut,
    };
    return {
        amountIn,
        usdIn,
        amountOut,
        usdOut,
        minOutputAmount,
        priceIn,
        priceOut,
        swapStrategy,
    };
}
function getSwapPathComparator(order) {
    return function (a, b) {
        for (const field of order || []) {
            const isLiquidity = field === "liquidity";
            const aVal = isLiquidity ? a.liquidity : a.path.length;
            const bVal = isLiquidity ? b.liquidity : b.path.length;
            if (aVal !== bVal) {
                if (isLiquidity) {
                    return aVal < bVal ? 1 : -1;
                }
                else {
                    return aVal < bVal ? -1 : 1;
                }
            }
        }
        return 0;
    };
}
exports.getSwapPathComparator = getSwapPathComparator;
function getPlainSwapAmountsByFromToken(tokenIn, tokenOut, amountIn) {
    const usdIn = (0, tokens_1.convertToUsd)(amountIn, tokenIn.decimals, tokenIn.prices.minPrice);
    const usdOut = usdIn;
    const amountOut = (0, tokens_1.convertToTokenAmount)(usdOut, tokenOut.decimals, tokenOut.prices.maxPrice);
    const priceIn = tokenIn.prices.minPrice;
    const priceOut = tokenOut.prices.maxPrice;
    const swapStrategy = {
        type: "noSwap",
        externalSwapQuote: undefined,
        swapPathStats: undefined,
        amountIn,
        amountOut,
        usdIn,
        usdOut,
        priceIn,
        priceOut,
        feesUsd: 0n,
    };
    return {
        amountIn,
        usdIn,
        amountOut,
        usdOut,
        minOutputAmount: amountOut,
        priceIn,
        priceOut,
        swapStrategy,
    };
}
function getPlainSwapAmountsByToToken(tokenIn, tokenOut, amountOut) {
    const priceIn = tokenIn.prices.minPrice;
    const priceOut = tokenOut.prices.maxPrice;
    const usdOut = (0, tokens_1.convertToUsd)(amountOut, tokenOut.decimals, priceOut);
    const usdIn = usdOut;
    const amountIn = (0, tokens_1.convertToTokenAmount)(usdIn, tokenIn.decimals, priceIn);
    const swapStrategy = {
        type: "noSwap",
        externalSwapQuote: undefined,
        swapPathStats: undefined,
        amountIn,
        amountOut,
        usdIn,
        usdOut,
        priceIn,
        priceOut,
        feesUsd: 0n,
    };
    return {
        amountIn,
        usdIn,
        amountOut,
        usdOut,
        minOutputAmount: amountOut,
        priceIn,
        priceOut,
        swapStrategy,
    };
}
