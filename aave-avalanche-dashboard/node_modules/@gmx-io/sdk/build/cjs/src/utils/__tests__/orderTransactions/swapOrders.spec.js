"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const viem_1 = require("viem");
const vitest_1 = require("vitest");
const chains_1 = require("../../../configs/chains");
const contracts_1 = require("../../../configs/contracts");
const markets_1 = require("../../../configs/markets");
const tokens_1 = require("../../../configs/tokens");
const orders_1 = require("../../../types/orders");
const numbers_1 = require("../../numbers");
const orderTransactions_1 = require("../../orderTransactions");
const uiFeeReceiver_1 = require("../../twap/uiFeeReceiver");
const mock_1 = require("../../../test/mock");
(0, vitest_1.beforeAll)(() => {
    // Mock Math.random to return a consistent value
    vitest_1.vi.spyOn(Math, "random").mockReturnValue(0.5);
});
(0, vitest_1.describe)("Swap Order Payloads", () => {
    const CHAIN_ID = chains_1.ARBITRUM;
    const RECEIVER = "0x1234567890123456789012345678901234567890";
    const UI_FEE_RECEIVER = "0x0987654321098765432109876543210987654321";
    const EXECUTION_GAS_LIMIT = 1000000n;
    const EXECUTION_FEE_AMOUNT = EXECUTION_GAS_LIMIT * mock_1.MOCK_GAS_PRICE;
    const REFERRAL_CODE = "0xf2742351cc0eca941ff90bf489789ee6169cbeacfdd38eba60012218fac1b7e5";
    const ETH_MARKET = markets_1.MARKETS[CHAIN_ID]["0x70d95587d40A2caf56bd97485aB3Eec10Bee6336"];
    const SLIPPAGE = 50; // 0.5%
    const ORDER_VAULT_ADDRESS = (0, contracts_1.getContract)(CHAIN_ID, "OrderVault");
    const commonParams = {
        chainId: CHAIN_ID,
        receiver: RECEIVER,
        uiFeeReceiver: UI_FEE_RECEIVER,
        executionFeeAmount: EXECUTION_FEE_AMOUNT,
        executionGasLimit: EXECUTION_GAS_LIMIT,
        referralCode: REFERRAL_CODE,
        validFromTime: 0n,
        autoCancel: false,
        externalSwapQuote: undefined,
        triggerRatio: undefined,
    };
    const USDC = (0, tokens_1.getTokenBySymbol)(CHAIN_ID, "USDC");
    const WETH = (0, tokens_1.getWrappedToken)(CHAIN_ID);
    const BTC = (0, tokens_1.getTokenBySymbol)(CHAIN_ID, "BTC");
    (0, vitest_1.describe)("buildSwapOrderPayload", () => {
        (0, vitest_1.it)("Swap Native Token to ERC20", () => {
            const params = {
                ...commonParams,
                payTokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                payTokenAmount: (0, numbers_1.parseValue)("1", WETH.decimals), // 1 ETH
                receiveTokenAddress: USDC.address,
                swapPath: [ETH_MARKET.marketTokenAddress],
                minOutputAmount: (0, numbers_1.parseValue)("1000", USDC.decimals), // 1000 USDC
                orderType: orders_1.OrderType.MarketSwap,
                allowedSlippage: SLIPPAGE,
            };
            const result = (0, orderTransactions_1.buildSwapOrderPayload)(params);
            (0, vitest_1.expect)(result).toEqual({
                orderPayload: {
                    addresses: {
                        receiver: RECEIVER,
                        cancellationReceiver: viem_1.zeroAddress,
                        callbackContract: viem_1.zeroAddress,
                        uiFeeReceiver: UI_FEE_RECEIVER,
                        market: viem_1.zeroAddress,
                        initialCollateralToken: WETH.address,
                        swapPath: [ETH_MARKET.marketTokenAddress],
                    },
                    numbers: {
                        sizeDeltaUsd: 0n,
                        initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1", WETH.decimals),
                        triggerPrice: 0n,
                        acceptablePrice: 0n,
                        executionFee: EXECUTION_FEE_AMOUNT,
                        callbackGasLimit: 0n,
                        minOutputAmount: (0, numbers_1.parseValue)("995", USDC.decimals),
                        validFromTime: 0n,
                    },
                    orderType: orders_1.OrderType.MarketSwap,
                    decreasePositionSwapType: orders_1.DecreasePositionSwapType.NoSwap,
                    isLong: false,
                    shouldUnwrapNativeToken: true,
                    autoCancel: false,
                    referralCode: REFERRAL_CODE,
                    dataList: [],
                },
                params,
                tokenTransfersParams: {
                    isNativePayment: true,
                    isNativeReceive: false,
                    initialCollateralTokenAddress: WETH.address,
                    initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1", WETH.decimals),
                    tokenTransfers: [
                        {
                            amount: EXECUTION_FEE_AMOUNT + (0, numbers_1.parseValue)("1", WETH.decimals),
                            destination: ORDER_VAULT_ADDRESS,
                            tokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                        },
                    ],
                    payTokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                    payTokenAmount: (0, numbers_1.parseValue)("1", WETH.decimals),
                    minOutputAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                    swapPath: [ETH_MARKET.marketTokenAddress],
                    value: EXECUTION_FEE_AMOUNT + (0, numbers_1.parseValue)("1", WETH.decimals),
                    externalCalls: undefined,
                },
            });
        });
        (0, vitest_1.it)("Swap ERC20 to Native Token", () => {
            const params = {
                ...commonParams,
                payTokenAddress: USDC.address,
                payTokenAmount: (0, numbers_1.parseValue)("1000", USDC.decimals), // 1000 USDC
                receiveTokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                swapPath: [ETH_MARKET.marketTokenAddress],
                minOutputAmount: (0, numbers_1.parseValue)("0.5", WETH.decimals), // 0.5 ETH
                orderType: orders_1.OrderType.MarketSwap,
                allowedSlippage: SLIPPAGE,
            };
            const result = (0, orderTransactions_1.buildSwapOrderPayload)(params);
            (0, vitest_1.expect)(result).toEqual({
                orderPayload: {
                    addresses: {
                        receiver: RECEIVER,
                        cancellationReceiver: viem_1.zeroAddress,
                        callbackContract: viem_1.zeroAddress,
                        uiFeeReceiver: UI_FEE_RECEIVER,
                        market: viem_1.zeroAddress,
                        initialCollateralToken: USDC.address,
                        swapPath: [ETH_MARKET.marketTokenAddress],
                    },
                    numbers: {
                        sizeDeltaUsd: 0n,
                        initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                        triggerPrice: 0n,
                        acceptablePrice: 0n,
                        executionFee: EXECUTION_FEE_AMOUNT,
                        callbackGasLimit: 0n,
                        minOutputAmount: (0, numbers_1.parseValue)("0.4975", WETH.decimals),
                        validFromTime: 0n,
                    },
                    orderType: orders_1.OrderType.MarketSwap,
                    decreasePositionSwapType: orders_1.DecreasePositionSwapType.NoSwap,
                    isLong: false,
                    shouldUnwrapNativeToken: true,
                    autoCancel: false,
                    referralCode: REFERRAL_CODE,
                    dataList: [],
                },
                params,
                tokenTransfersParams: {
                    isNativePayment: false,
                    isNativeReceive: true,
                    initialCollateralTokenAddress: USDC.address,
                    initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                    tokenTransfers: [
                        {
                            amount: EXECUTION_FEE_AMOUNT,
                            destination: ORDER_VAULT_ADDRESS,
                            tokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                        },
                        {
                            amount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                            destination: ORDER_VAULT_ADDRESS,
                            tokenAddress: USDC.address,
                        },
                    ],
                    payTokenAddress: USDC.address,
                    payTokenAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                    minOutputAmount: (0, numbers_1.parseValue)("0.5", WETH.decimals),
                    swapPath: [ETH_MARKET.marketTokenAddress],
                    value: EXECUTION_FEE_AMOUNT,
                    externalCalls: undefined,
                },
            });
        });
        (0, vitest_1.it)("swap ERC20 to ERC20", () => {
            const params = {
                ...commonParams,
                payTokenAddress: USDC.address,
                payTokenAmount: (0, numbers_1.parseValue)("1000", USDC.decimals), // 1000 USDC
                receiveTokenAddress: BTC.address,
                swapPath: [ETH_MARKET.marketTokenAddress],
                minOutputAmount: (0, numbers_1.parseValue)("0.001", BTC.decimals), // 0.01 BTC
                orderType: orders_1.OrderType.MarketSwap,
                allowedSlippage: SLIPPAGE,
            };
            const result = (0, orderTransactions_1.buildSwapOrderPayload)(params);
            (0, vitest_1.expect)(result).toEqual({
                orderPayload: {
                    addresses: {
                        receiver: RECEIVER,
                        cancellationReceiver: viem_1.zeroAddress,
                        callbackContract: viem_1.zeroAddress,
                        uiFeeReceiver: UI_FEE_RECEIVER,
                        market: viem_1.zeroAddress,
                        initialCollateralToken: USDC.address,
                        swapPath: [ETH_MARKET.marketTokenAddress],
                    },
                    numbers: {
                        sizeDeltaUsd: 0n,
                        initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                        triggerPrice: 0n,
                        acceptablePrice: 0n,
                        executionFee: EXECUTION_FEE_AMOUNT,
                        callbackGasLimit: 0n,
                        minOutputAmount: (0, numbers_1.parseValue)("0.000995", BTC.decimals),
                        validFromTime: 0n,
                    },
                    orderType: orders_1.OrderType.MarketSwap,
                    decreasePositionSwapType: orders_1.DecreasePositionSwapType.NoSwap,
                    isLong: false,
                    shouldUnwrapNativeToken: false,
                    autoCancel: false,
                    referralCode: REFERRAL_CODE,
                    dataList: [],
                },
                params,
                tokenTransfersParams: {
                    isNativePayment: false,
                    isNativeReceive: false,
                    initialCollateralTokenAddress: USDC.address,
                    initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                    tokenTransfers: [
                        {
                            amount: EXECUTION_FEE_AMOUNT,
                            destination: ORDER_VAULT_ADDRESS,
                            tokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                        },
                        {
                            amount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                            destination: ORDER_VAULT_ADDRESS,
                            tokenAddress: USDC.address,
                        },
                    ],
                    payTokenAddress: USDC.address,
                    payTokenAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                    minOutputAmount: (0, numbers_1.parseValue)("0.001", BTC.decimals),
                    swapPath: [ETH_MARKET.marketTokenAddress],
                    value: EXECUTION_FEE_AMOUNT,
                    externalCalls: undefined,
                },
            });
        });
        (0, vitest_1.it)("limit swap with trigger ratio", () => {
            const params = {
                ...commonParams,
                payTokenAddress: USDC.address,
                payTokenAmount: (0, numbers_1.parseValue)("1000", USDC.decimals), // 1000 USDC
                receiveTokenAddress: WETH.address,
                swapPath: [ETH_MARKET.marketTokenAddress],
                minOutputAmount: (0, numbers_1.parseValue)("0.5", WETH.decimals),
                orderType: orders_1.OrderType.LimitSwap,
                allowedSlippage: SLIPPAGE,
                triggerRatio: (0, numbers_1.parseValue)("1", 30), // 1:1 ratio
            };
            const result = (0, orderTransactions_1.buildSwapOrderPayload)(params);
            (0, vitest_1.expect)(result).toEqual({
                orderPayload: {
                    addresses: {
                        receiver: RECEIVER,
                        cancellationReceiver: viem_1.zeroAddress,
                        callbackContract: viem_1.zeroAddress,
                        uiFeeReceiver: UI_FEE_RECEIVER,
                        market: viem_1.zeroAddress,
                        initialCollateralToken: USDC.address,
                        swapPath: [ETH_MARKET.marketTokenAddress],
                    },
                    numbers: {
                        sizeDeltaUsd: 0n,
                        initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                        triggerPrice: (0, numbers_1.parseValue)("1", 30),
                        acceptablePrice: 0n,
                        executionFee: EXECUTION_FEE_AMOUNT,
                        callbackGasLimit: 0n,
                        minOutputAmount: (0, numbers_1.parseValue)("0.4975", WETH.decimals),
                        validFromTime: 0n,
                    },
                    orderType: orders_1.OrderType.LimitSwap,
                    decreasePositionSwapType: orders_1.DecreasePositionSwapType.NoSwap,
                    isLong: false,
                    shouldUnwrapNativeToken: false,
                    autoCancel: false,
                    referralCode: REFERRAL_CODE,
                    dataList: [],
                },
                params,
                tokenTransfersParams: {
                    isNativePayment: false,
                    isNativeReceive: false,
                    initialCollateralTokenAddress: USDC.address,
                    initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                    tokenTransfers: [
                        {
                            amount: EXECUTION_FEE_AMOUNT,
                            destination: ORDER_VAULT_ADDRESS,
                            tokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                        },
                        {
                            amount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                            destination: ORDER_VAULT_ADDRESS,
                            tokenAddress: USDC.address,
                        },
                    ],
                    payTokenAddress: USDC.address,
                    payTokenAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                    minOutputAmount: (0, numbers_1.parseValue)("0.5", WETH.decimals),
                    swapPath: [ETH_MARKET.marketTokenAddress],
                    value: EXECUTION_FEE_AMOUNT,
                    externalCalls: undefined,
                },
            });
        });
        (0, vitest_1.it)("TWAP Swap Native Token to ERC20", () => {
            const params = {
                ...commonParams,
                payTokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                payTokenAmount: (0, numbers_1.parseValue)("1", WETH.decimals), // 1 ETH
                orderType: orders_1.OrderType.MarketSwap,
                triggerRatio: (0, numbers_1.parseValue)("1", 30),
                allowedSlippage: SLIPPAGE,
                receiveTokenAddress: USDC.address,
                swapPath: [ETH_MARKET.marketTokenAddress],
                externalSwapQuote: undefined,
                minOutputAmount: (0, numbers_1.parseValue)("1000", USDC.decimals), // 1000 USDC
            };
            const twapParams = {
                duration: {
                    hours: 1,
                    minutes: 0,
                },
                numberOfParts: 4,
            };
            const result = (0, orderTransactions_1.buildTwapOrdersPayloads)(params, twapParams);
            // Calculate time intervals for each part
            const totalDurationInSeconds = twapParams.duration.hours * 3600 + twapParams.duration.minutes * 60;
            const startTime = Math.ceil(Date.now() / 1000);
            const intervalInSeconds = totalDurationInSeconds / (twapParams.numberOfParts - 1);
            const expectedOrders = Array.from({ length: twapParams.numberOfParts }, (_, i) => {
                const validFromTime = BigInt(Math.floor(startTime + intervalInSeconds * i));
                const uiFeeReceiver = `0xff00000000000000000000000000000004800001`;
                const decoded = (0, uiFeeReceiver_1.decodeTwapUiFeeReceiver)(uiFeeReceiver);
                (0, vitest_1.expect)(decoded).toEqual({
                    twapId: "8000",
                    numberOfParts: twapParams.numberOfParts,
                    isExpress: false,
                });
                return {
                    orderPayload: {
                        addresses: {
                            receiver: RECEIVER,
                            cancellationReceiver: viem_1.zeroAddress,
                            callbackContract: viem_1.zeroAddress,
                            uiFeeReceiver,
                            market: viem_1.zeroAddress,
                            initialCollateralToken: WETH.address,
                            swapPath: [ETH_MARKET.marketTokenAddress],
                        },
                        numbers: {
                            sizeDeltaUsd: 0n,
                            initialCollateralDeltaAmount: params.payTokenAmount / 4n,
                            triggerPrice: (0, numbers_1.parseValue)("1", 30),
                            acceptablePrice: 0n,
                            executionFee: EXECUTION_FEE_AMOUNT / 4n,
                            callbackGasLimit: 0n,
                            minOutputAmount: 0n,
                            validFromTime,
                        },
                        orderType: orders_1.OrderType.LimitSwap,
                        decreasePositionSwapType: orders_1.DecreasePositionSwapType.NoSwap,
                        isLong: false,
                        shouldUnwrapNativeToken: true,
                        autoCancel: false,
                        referralCode: REFERRAL_CODE,
                        dataList: [],
                    },
                    params: {
                        ...params,
                        payTokenAmount: params.payTokenAmount / 4n,
                        executionFeeAmount: EXECUTION_FEE_AMOUNT / 4n,
                        minOutputAmount: 0n,
                        orderType: orders_1.OrderType.LimitSwap,
                        allowedSlippage: 0,
                        uiFeeReceiver,
                        validFromTime,
                    },
                    tokenTransfersParams: {
                        isNativePayment: true,
                        isNativeReceive: false,
                        initialCollateralTokenAddress: WETH.address,
                        initialCollateralDeltaAmount: params.payTokenAmount / 4n,
                        tokenTransfers: [
                            {
                                amount: EXECUTION_FEE_AMOUNT / 4n + params.payTokenAmount / 4n,
                                destination: ORDER_VAULT_ADDRESS,
                                tokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                            },
                        ],
                        payTokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                        payTokenAmount: params.payTokenAmount / 4n,
                        minOutputAmount: 0n,
                        swapPath: [ETH_MARKET.marketTokenAddress],
                        value: EXECUTION_FEE_AMOUNT / 4n + params.payTokenAmount / 4n,
                        externalCalls: undefined,
                    },
                };
            });
            (0, vitest_1.expect)(result).toEqual(expectedOrders);
            (0, vitest_1.expect)(expectedOrders.every((co) => (0, orderTransactions_1.getIsTwapOrderPayload)(co.orderPayload))).toBe(true);
        });
        (0, vitest_1.it)("Market Swap with Undefined Optional Parameters", () => {
            const params = {
                ...commonParams,
                payTokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                payTokenAmount: (0, numbers_1.parseValue)("1", WETH.decimals), // 1 ETH
                receiveTokenAddress: USDC.address,
                swapPath: [ETH_MARKET.marketTokenAddress],
                minOutputAmount: (0, numbers_1.parseValue)("1000", USDC.decimals), // 1000 USDC
                orderType: orders_1.OrderType.MarketSwap,
                allowedSlippage: SLIPPAGE,
                uiFeeReceiver: undefined,
                referralCode: undefined,
                validFromTime: undefined,
            };
            const result = (0, orderTransactions_1.buildSwapOrderPayload)(params);
            (0, vitest_1.expect)(result).toEqual({
                orderPayload: {
                    addresses: {
                        receiver: RECEIVER,
                        cancellationReceiver: viem_1.zeroAddress,
                        callbackContract: viem_1.zeroAddress,
                        uiFeeReceiver: viem_1.zeroAddress,
                        market: viem_1.zeroAddress,
                        initialCollateralToken: WETH.address,
                        swapPath: [ETH_MARKET.marketTokenAddress],
                    },
                    numbers: {
                        sizeDeltaUsd: 0n,
                        initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1", WETH.decimals),
                        triggerPrice: 0n,
                        acceptablePrice: 0n,
                        executionFee: EXECUTION_FEE_AMOUNT,
                        callbackGasLimit: 0n,
                        minOutputAmount: (0, numbers_1.parseValue)("995", USDC.decimals),
                        validFromTime: 0n,
                    },
                    orderType: orders_1.OrderType.MarketSwap,
                    decreasePositionSwapType: orders_1.DecreasePositionSwapType.NoSwap,
                    isLong: false,
                    shouldUnwrapNativeToken: true,
                    autoCancel: false,
                    dataList: [],
                    referralCode: viem_1.zeroHash,
                },
                params,
                tokenTransfersParams: {
                    isNativePayment: true,
                    isNativeReceive: false,
                    initialCollateralTokenAddress: WETH.address,
                    initialCollateralDeltaAmount: (0, numbers_1.parseValue)("1", WETH.decimals),
                    tokenTransfers: [
                        {
                            amount: EXECUTION_FEE_AMOUNT + (0, numbers_1.parseValue)("1", WETH.decimals),
                            destination: ORDER_VAULT_ADDRESS,
                            tokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                        },
                    ],
                    payTokenAddress: tokens_1.NATIVE_TOKEN_ADDRESS,
                    payTokenAmount: (0, numbers_1.parseValue)("1", WETH.decimals),
                    minOutputAmount: (0, numbers_1.parseValue)("1000", USDC.decimals),
                    swapPath: [ETH_MARKET.marketTokenAddress],
                    value: EXECUTION_FEE_AMOUNT + (0, numbers_1.parseValue)("1", WETH.decimals),
                    externalCalls: undefined,
                },
            });
        });
    });
});
