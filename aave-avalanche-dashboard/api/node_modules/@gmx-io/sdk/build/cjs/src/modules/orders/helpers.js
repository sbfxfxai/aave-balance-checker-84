"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.swap = exports.increaseOrderHelper = void 0;
const orders_1 = require("../../types/orders");
const objects_1 = require("../../utils/objects");
const swap_1 = require("../../utils/swap");
const swapPath_1 = require("../../utils/swap/swapPath");
const tokens_1 = require("../../utils/tokens");
const increase_1 = require("../../utils/trade/increase");
function passThoughOrFetch(value, condition, fetchFn) {
    if (condition(value)) {
        return value;
    }
    return fetchFn();
}
async function getAndValidateBaseParams(sdk, params) {
    const [marketsInfoResult, uiFeeFactor, gasPrice, gasLimits] = await Promise.all([
        passThoughOrFetch({
            marketsInfoData: params.marketsInfoData,
            tokensData: params.tokensData,
        }, (input) => Boolean(input.marketsInfoData) && Boolean(input.tokensData), () => sdk.markets.getMarketsInfo()),
        passThoughOrFetch(params.uiFeeFactor, (input) => input !== undefined, () => sdk.utils.getUiFeeFactor()),
        passThoughOrFetch(params.gasPrice, (input) => input !== undefined, () => sdk.utils.getGasPrice()),
        passThoughOrFetch(params.gasLimits, (input) => input !== undefined, () => sdk.utils.getGasLimits()),
    ]);
    if (!marketsInfoResult.marketsInfoData) {
        throw new Error("Markets info data is not available");
    }
    if (!marketsInfoResult.tokensData) {
        throw new Error("Tokens data is not available");
    }
    if (uiFeeFactor === undefined) {
        throw new Error("Ui fee factor is not available");
    }
    if (gasPrice === undefined) {
        throw new Error("Gas price is not available");
    }
    if (gasLimits === undefined) {
        throw new Error("Gas limits are not available");
    }
    return {
        tokensData: marketsInfoResult.tokensData,
        marketsInfoData: marketsInfoResult.marketsInfoData,
        uiFeeFactor,
        gasPrice,
        gasLimits,
    };
}
async function increaseOrderHelper(sdk, params) {
    const { tokensData, marketsInfoData, uiFeeFactor, gasLimits, gasPrice } = await getAndValidateBaseParams(sdk, params);
    const isLimit = Boolean(params.limitPrice);
    const fromToken = tokensData[params.payTokenAddress];
    const collateralToken = tokensData[params.collateralTokenAddress];
    if (!fromToken) {
        throw new Error("payTokenAddress: token is not available");
    }
    if (!collateralToken) {
        throw new Error("collateralTokenAddress: token is not available");
    }
    if (fromToken.isSynthetic) {
        throw new Error("payTokenAddress: synthetic tokens are not supported");
    }
    if (collateralToken.isSynthetic) {
        throw new Error("collateralTokenAddress: synthetic tokens are not supported");
    }
    const marketInfo = (0, objects_1.getByKey)(marketsInfoData, params.marketAddress);
    if (!marketInfo) {
        throw new Error("Market info is not available");
    }
    const collateralTokenAddress = collateralToken.address;
    const allowedSlippage = params.allowedSlippageBps ?? 100;
    const findSwapPath = (0, swapPath_1.createFindSwapPath)({
        chainId: sdk.chainId,
        fromTokenAddress: params.payTokenAddress,
        toTokenAddress: collateralTokenAddress,
        marketsInfoData,
        gasEstimationParams: {
            gasLimits,
            gasPrice,
            tokensData,
        },
        isExpressFeeSwap: false,
    });
    const payOrSizeAmount = "payAmount" in params ? params.payAmount : params.sizeAmount;
    const increaseAmounts = (0, increase_1.getIncreasePositionAmounts)({
        marketInfo,
        indexToken: marketInfo.indexToken,
        initialCollateralToken: fromToken,
        collateralToken,
        isLong: params.isLong,
        initialCollateralAmount: payOrSizeAmount,
        position: undefined,
        indexTokenAmount: payOrSizeAmount,
        leverage: params.leverage,
        triggerPrice: params.limitPrice,
        limitOrderType: params.limitPrice ? orders_1.OrderType.LimitIncrease : undefined,
        userReferralInfo: undefined,
        strategy: "payAmount" in params ? "leverageByCollateral" : "leverageBySize",
        findSwapPath: findSwapPath,
        uiFeeFactor,
        acceptablePriceImpactBuffer: params.acceptablePriceImpactBuffer,
        fixedAcceptablePriceImpactBps: params.fixedAcceptablePriceImpactBps,
        externalSwapQuote: undefined,
        marketsInfoData,
        chainId: sdk.chainId,
        externalSwapQuoteParams: undefined,
        isSetAcceptablePriceImpactEnabled: false,
    });
    const createIncreaseOrderParams = {
        marketsInfoData,
        tokensData,
        isLimit,
        marketAddress: params.marketAddress,
        fromToken: tokensData[params.payTokenAddress],
        allowedSlippage,
        collateralToken,
        referralCodeForTxn: params.referralCodeForTxn,
        triggerPrice: params.limitPrice,
        collateralTokenAddress: collateralToken.address,
        isLong: params.isLong,
        receiveTokenAddress: collateralTokenAddress,
        indexToken: marketInfo.indexToken,
        marketInfo,
        skipSimulation: params.skipSimulation,
        increaseAmounts,
    };
    return sdk.orders.createIncreaseOrder(createIncreaseOrderParams);
}
exports.increaseOrderHelper = increaseOrderHelper;
function getTriggerRatio({ toToken, fromToken, triggerPrice, }) {
    const fromTokenPrice = fromToken?.prices.minPrice;
    const markPrice = toToken.prices.minPrice;
    const markRatio = (0, tokens_1.getTokensRatioByPrice)({
        fromToken,
        toToken,
        fromPrice: fromTokenPrice,
        toPrice: markPrice,
    });
    const triggerRatio = {
        ratio: triggerPrice > 0 ? triggerPrice : markRatio.ratio,
        largestToken: markRatio.largestToken,
        smallestToken: markRatio.smallestToken,
    };
    return triggerRatio;
}
async function swap(sdk, params) {
    const { tokensData, marketsInfoData, uiFeeFactor, gasLimits, gasPrice } = await getAndValidateBaseParams(sdk, params);
    const fromToken = tokensData[params.fromTokenAddress];
    const toToken = tokensData[params.toTokenAddress];
    if (!fromToken || !toToken) {
        throw new Error("From or to token is not available");
    }
    if (toToken.isSynthetic) {
        throw new Error(`Synthetic tokens are not supported: ${toToken.symbol}`);
    }
    if (fromToken.isSynthetic) {
        throw new Error(`Synthetic tokens are not supported: ${fromToken.symbol}`);
    }
    const isLimit = Boolean(params.triggerPrice);
    if (!fromToken || !toToken) {
        return undefined;
    }
    const findSwapPath = (0, swapPath_1.createFindSwapPath)({
        chainId: sdk.chainId,
        fromTokenAddress: params.fromTokenAddress,
        toTokenAddress: params.toTokenAddress,
        marketsInfoData,
        gasEstimationParams: {
            gasLimits,
            gasPrice,
            tokensData,
        },
        isExpressFeeSwap: false,
    });
    const isWrapOrUnwrap = Boolean(fromToken && toToken && ((0, tokens_1.getIsWrap)(fromToken, toToken) || (0, tokens_1.getIsUnwrap)(fromToken, toToken)));
    if (isWrapOrUnwrap) {
        const fromTokenPrice = fromToken.prices.minPrice;
        const tokenAmount = "fromAmount" in params ? params.fromAmount : params.toAmount;
        const usdAmount = (0, tokens_1.convertToUsd)(tokenAmount, fromToken.decimals, fromTokenPrice);
        const price = fromTokenPrice;
        return {
            amountIn: tokenAmount,
            usdIn: usdAmount,
            amountOut: tokenAmount,
            usdOut: usdAmount,
            swapPathStats: undefined,
            priceIn: price,
            priceOut: price,
            minOutputAmount: tokenAmount,
        };
    }
    const swapOptimizationOrder = isLimit ? ["length", "liquidity"] : undefined;
    let swapAmounts;
    const triggerRatio = params.triggerPrice
        ? getTriggerRatio({
            fromToken,
            toToken,
            triggerPrice: params.triggerPrice,
        })
        : undefined;
    if ("fromAmount" in params) {
        swapAmounts = (0, swap_1.getSwapAmountsByFromValue)({
            tokenIn: fromToken,
            tokenOut: toToken,
            amountIn: params.fromAmount,
            triggerRatio,
            isLimit,
            findSwapPath: findSwapPath,
            uiFeeFactor,
            swapOptimizationOrder,
            allowedSwapSlippageBps: isLimit ? BigInt(params.allowedSlippageBps ?? 100) : undefined,
            marketsInfoData,
            chainId: sdk.chainId,
            externalSwapQuoteParams: undefined,
        });
    }
    else {
        swapAmounts = (0, swap_1.getSwapAmountsByToValue)({
            tokenIn: fromToken,
            tokenOut: toToken,
            amountOut: params.toAmount,
            triggerRatio,
            isLimit: isLimit,
            findSwapPath: findSwapPath,
            uiFeeFactor,
            swapOptimizationOrder,
            allowedSwapSlippageBps: isLimit ? BigInt(params.allowedSlippageBps ?? 100) : undefined,
            marketsInfoData,
            chainId: sdk.chainId,
            externalSwapQuoteParams: undefined,
        });
    }
    if (!swapAmounts) {
        return undefined;
    }
    const createSwapOrderParams = {
        tokensData,
        fromToken: tokensData[params.fromTokenAddress],
        toToken: tokensData[params.toTokenAddress],
        swapAmounts,
        isLimit,
        allowedSlippage: params.allowedSlippageBps ?? 100,
        referralCodeForTxn: params.referralCodeForTxn,
        triggerPrice: params.triggerPrice,
    };
    return sdk.orders.createSwapOrder(createSwapOrderParams);
}
exports.swap = swap;
