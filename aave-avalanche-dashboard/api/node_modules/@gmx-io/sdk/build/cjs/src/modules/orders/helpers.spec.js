"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const chains_1 = require("../../configs/chains");
const objects_1 = require("../../utils/objects");
const swapPath = __importStar(require("../../utils/swap/swapPath"));
const testUtil_1 = require("../../utils/testUtil");
const tradeAmounts = __importStar(require("../../utils/trade/increase"));
(0, vitest_1.describe)("increaseOrderHelper", () => {
    let marketsInfoData;
    let tokensData;
    let mockParams;
    let createIncreaseOrderSpy;
    let market;
    let payToken;
    let collateralToken;
    (0, vitest_1.beforeAll)(async () => {
        const result = await testUtil_1.arbitrumSdk.markets.getMarketsInfo();
        if (!result.marketsInfoData || !result.tokensData) {
            throw new Error("Markets info data or tokens data is not available");
        }
        marketsInfoData = result.marketsInfoData;
        tokensData = result.tokensData;
        market = (0, objects_1.getByKey)(marketsInfoData, "0x70d95587d40A2caf56bd97485aB3Eec10Bee6336");
        if (!market) {
            throw new Error("Market is not available");
        }
        payToken = market.indexToken;
        collateralToken = market.shortToken;
        mockParams = {
            payAmount: 1000n,
            marketAddress: "0x70d95587d40A2caf56bd97485aB3Eec10Bee6336",
            payTokenAddress: market.indexToken.address,
            collateralTokenAddress: market.shortToken.address,
            allowedSlippageBps: 125,
            leverage: 50000n,
            marketsInfoData,
            tokensData,
        };
    });
    (0, vitest_1.describe)("validation", () => {
        (0, vitest_1.it)("should throw an error if wrong collateral token selected", async () => {
            const e = await testUtil_1.arbitrumSdk.orders
                .long({
                ...mockParams,
                marketAddress: "0x47c031236e19d024b42f8AE6780E44A573170703",
                collateralTokenAddress: "0xC4da4c24fd591125c3F47b340b6f4f76111883d8",
            })
                .catch((error) => {
                return error.message;
            });
            await (0, vitest_1.expect)(e).toBe("collateralTokenAddress: synthetic tokens are not supported");
        });
        (0, vitest_1.it)("should throw an error if wrong collateral token selected", async () => {
            const e = await testUtil_1.arbitrumSdk.orders
                .long({
                ...mockParams,
                collateralTokenAddress: "0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A",
            })
                .catch((error) => {
                return error.message;
            });
            await (0, vitest_1.expect)(e).toBe("collateralTokenAddress: token is not available");
        });
        (0, vitest_1.it)("should throw an error if wrong collateral token selected", async () => {
            const e = await testUtil_1.arbitrumSdk.orders
                .long({
                ...mockParams,
                collateralTokenAddress: "0x912CE59144191C1204E64559FE8253a0e49E6548",
            })
                .catch((error) => {
                return error.message;
            });
            await (0, vitest_1.expect)(e).toBe("Invalid collateral token. Only long WETH and short USDC tokens are available.");
        });
    });
    (0, vitest_1.describe)("parameters", () => {
        (0, vitest_1.beforeEach)(() => {
            vitest_1.vi.clearAllMocks();
            createIncreaseOrderSpy = vitest_1.vi.spyOn(testUtil_1.arbitrumSdk.orders, "createIncreaseOrder").mockResolvedValue();
        });
        (0, vitest_1.it)("should call createIncreaseOrder with correct parameters for a market order with payAmount", async () => {
            const findSwapPathSpy = vitest_1.vi.spyOn(swapPath, "createFindSwapPath");
            const getIncreasePositionAmountsSpy = vitest_1.vi.spyOn(tradeAmounts, "getIncreasePositionAmounts");
            await testUtil_1.arbitrumSdk.orders.long(mockParams);
            (0, vitest_1.expect)(findSwapPathSpy).toHaveBeenCalledWith(vitest_1.expect.objectContaining({
                chainId: chains_1.ARBITRUM,
                fromTokenAddress: payToken.address,
                toTokenAddress: collateralToken.address,
                marketsInfoData: vitest_1.expect.any(Object),
            }));
            (0, vitest_1.expect)(getIncreasePositionAmountsSpy).toHaveBeenCalledWith(vitest_1.expect.objectContaining({
                isLong: true,
                initialCollateralAmount: 1000n,
                leverage: 50000n,
                strategy: "leverageByCollateral",
                marketInfo: market,
            }));
            (0, vitest_1.expect)(createIncreaseOrderSpy).toHaveBeenCalledWith(vitest_1.expect.objectContaining({
                marketsInfoData: vitest_1.expect.any(Object),
                tokensData: vitest_1.expect.any(Object),
                marketInfo: market,
                indexToken: market.indexToken,
                isLimit: false,
                marketAddress: market.marketTokenAddress,
                allowedSlippage: 125,
                collateralTokenAddress: collateralToken.address,
                collateralToken,
                isLong: true,
                receiveTokenAddress: collateralToken.address,
                increaseAmounts: vitest_1.expect.objectContaining({
                    initialCollateralAmount: 1000n,
                    estimatedLeverage: 50000n,
                    triggerPrice: undefined,
                    acceptablePrice: 0n,
                    acceptablePriceDeltaBps: 0n,
                    positionFeeUsd: 0n,
                    uiFeeUsd: 0n,
                    swapUiFeeUsd: 0n,
                    feeDiscountUsd: 0n,
                    borrowingFeeUsd: 0n,
                    fundingFeeUsd: 0n,
                    positionPriceImpactDeltaUsd: 0n,
                    limitOrderType: undefined,
                    triggerThresholdType: undefined,
                    swapStrategy: vitest_1.expect.any(Object),
                }),
            }));
        });
    });
});
