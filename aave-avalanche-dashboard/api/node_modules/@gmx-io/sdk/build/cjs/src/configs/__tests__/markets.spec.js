"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const viem_1 = require("viem");
const vitest_1 = require("vitest");
const chains_1 = require("../chains");
const markets_1 = require("../markets");
const oracleKeeper_1 = require("../oracleKeeper");
const getKeeperMarkets = async (chainId) => {
    const res = await fetch(`${(0, oracleKeeper_1.getOracleKeeperUrl)(chainId)}/markets`);
    const data = (await res.json());
    if (!data || !data.markets || data.markets.length === 0)
        throw Error("No markets in response");
    return data;
};
(0, vitest_1.describe)("markets config", () => {
    chains_1.CONTRACTS_CHAIN_IDS_DEV.forEach(async (chainId) => {
        (0, vitest_1.it)(`markets should be consistent with keeper for ${chainId}`, async () => {
            const keeperMarkets = await (0, viem_1.withRetry)(() => getKeeperMarkets(chainId), {
                retryCount: 2,
            });
            Object.entries(markets_1.MARKETS[chainId]).forEach(([marketAddress, market]) => {
                (0, vitest_1.expect)(marketAddress).toBe(market.marketTokenAddress);
                const keeperMarket = keeperMarkets.markets.find((m) => m.marketToken === marketAddress);
                (0, vitest_1.expect)(keeperMarket).toBeDefined();
                (0, vitest_1.expect)(keeperMarket?.indexToken).toBe(market.indexTokenAddress);
                (0, vitest_1.expect)(keeperMarket?.longToken).toBe(market.longTokenAddress);
                (0, vitest_1.expect)(keeperMarket?.shortToken).toBe(market.shortTokenAddress);
                (0, vitest_1.expect)(keeperMarket?.marketToken).toBe(marketAddress);
            });
        });
    });
});
