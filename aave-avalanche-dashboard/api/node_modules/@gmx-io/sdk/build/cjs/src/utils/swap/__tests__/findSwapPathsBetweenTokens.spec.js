"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const findSwapPathsBetweenTokens_1 = require("../findSwapPathsBetweenTokens");
(0, vitest_1.describe)("findSwapPathsBetweenTokens", () => {
    (0, vitest_1.it)("should find direct swap routes between tokens", () => {
        const graph = {
            ETH: {
                USDC: ["ETH [ETH-USDC]"],
            },
            USDC: {
                ETH: ["ETH [ETH-USDC]"],
            },
        };
        const result = (0, findSwapPathsBetweenTokens_1.findSwapPathsBetweenTokens)(graph);
        (0, vitest_1.expect)(result).toEqual({
            ETH: {
                USDC: [[]],
            },
        });
    });
    (0, vitest_1.it)("should find multi-hop swap routes", () => {
        const graph = {
            ETH: {
                USDC: ["ETH [ETH-USDC]"],
                BTC: ["BTC [BTC-ETH]"],
            },
            USDC: {
                ETH: ["ETH [ETH-USDC]"],
                BTC: ["BTC [BTC-USDC]"],
            },
            BTC: {
                ETH: ["BTC [BTC-ETH]"],
                USDC: ["BTC [BTC-USDC]"],
            },
        };
        const result = (0, findSwapPathsBetweenTokens_1.findSwapPathsBetweenTokens)(graph);
        (0, vitest_1.expect)(result).toEqual({
            BTC: {
                ETH: [[], ["USDC"]],
                USDC: [[], ["ETH"]],
            },
            ETH: {
                USDC: [[], ["BTC"]],
            },
        });
    });
    (0, vitest_1.it)("should handle multiple markets between same tokens", () => {
        const graph = {
            ETH: {
                USDC: ["ETH [ETH-USDC]", "ETH [ETH-USDC-2]"],
            },
            USDC: {
                ETH: ["ETH [ETH-USDC]", "ETH [ETH-USDC-2]"],
            },
        };
        const result = (0, findSwapPathsBetweenTokens_1.findSwapPathsBetweenTokens)(graph);
        (0, vitest_1.expect)(result).toEqual({
            ETH: {
                USDC: [[], ["USDC", "ETH"]],
            },
        });
    });
    (0, vitest_1.it)("should not include self-loops", () => {
        const graph = {
            ETH: {
                ETH: ["ETH [ETH-ETH]"],
            },
        };
        const result = (0, findSwapPathsBetweenTokens_1.findSwapPathsBetweenTokens)(graph);
        (0, vitest_1.expect)(result).toEqual({});
    });
    (0, vitest_1.it)("should handle empty graph", () => {
        const graph = {};
        const result = (0, findSwapPathsBetweenTokens_1.findSwapPathsBetweenTokens)(graph);
        (0, vitest_1.expect)(result).toEqual({});
    });
    (0, vitest_1.it)("should handle isolated tokens", () => {
        const graph = {
            ETH: {},
            USDC: {},
        };
        const result = (0, findSwapPathsBetweenTokens_1.findSwapPathsBetweenTokens)(graph);
        (0, vitest_1.expect)(result).toEqual({});
    });
    (0, vitest_1.it)("should respect MAX_EDGE_PATH_LENGTH limit", () => {
        const graph = {
            ETH: {
                USDC: ["ETH [ETH-USDC]"],
            },
            USDC: {
                ETH: ["ETH [ETH-USDC]"],
                BTC: ["BTC [BTC-USDC]"],
            },
            BTC: {
                USDC: ["BTC [BTC-USDC]"],
                WBTC: ["WBTC [WBTC-BTC]"],
            },
            WBTC: {
                BTC: ["WBTC [WBTC-BTC]"],
                USDT: ["USDT [USDT-WBTC]"],
            },
            USDT: {
                WBTC: ["USDT [USDT-WBTC]"],
                DAI: ["DAI [DAI-USDT]"],
            },
            DAI: {
                USDT: ["DAI [DAI-USDT]"],
            },
        };
        const result = (0, findSwapPathsBetweenTokens_1.findSwapPathsBetweenTokens)(graph);
        // Assuming MAX_EDGE_PATH_LENGTH is 3, we shouldn't see paths longer than 3 hops
        // So node path length should be less than or equal to 2
        for (const tokenA in result) {
            for (const tokenB in result[tokenA]) {
                for (const path of result[tokenA][tokenB]) {
                    (0, vitest_1.expect)(path.length).toBeLessThanOrEqual(2);
                }
            }
        }
    });
    (0, vitest_1.it)("should find swap routes through common node pairs", () => {
        // A - USDC - B
        //   ^
        //   |
        //   2 markets
        const graph = {
            A: {
                USDC: ["A [A-USDC]", "A2 [A-USDC]"],
            },
            B: {
                USDC: ["B [B-USDC]"],
            },
            USDC: {
                A: ["A [A-USDC]", "A2 [A-USDC]"],
                B: ["B [B-USDC]"],
            },
        };
        const result = (0, findSwapPathsBetweenTokens_1.findSwapPathsBetweenTokens)(graph);
        (0, vitest_1.expect)(result).toEqual({
            A: {
                B: [["USDC"]],
                USDC: [[], ["USDC", "A"]],
            },
            B: {
                USDC: [[], ["USDC", "A"]],
            },
        });
    });
});
