"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMaxLiquidityMarketForTokenEdge = exports.getMaxLiquidityMarketSwapPathFromTokenSwapPaths = exports.findAllReachableTokens = exports.getMarketAdjacencyGraph = exports.getTokenSwapPathsForTokenPairPrebuilt = exports.getTokenSwapPathsForTokenPair = exports.marketRouteToMarketEdges = exports.getBestMarketForTokenEdge = exports.getMarketsForTokenPair = exports.getNaiveBestMarketSwapPathsFromTokenSwapPaths = exports.getBestSwapPath = exports.createNaiveNetworkEstimator = exports.createNaiveSwapEstimator = exports.createMarketEdgeLiquidityGetter = exports.createSwapEstimator = void 0;
const viem_1 = require("viem");
const bigmath_1 = require("../bigmath");
const fees_1 = require("../fees");
const getNaiveEstimatedGasBySwapCount_1 = require("../fees/getNaiveEstimatedGasBySwapCount");
const markets_1 = require("../markets");
const numbers_1 = require("../numbers");
const objects_1 = require("../objects");
const constants_1 = require("./constants");
const preparedSwapData_1 = require("./preparedSwapData");
const swapStats_1 = require("./swapStats");
const createSwapEstimator = (marketsInfoData, isAtomicSwap) => {
    return (e, usdIn) => {
        const marketInfo = marketsInfoData[e.marketAddress];
        if (!marketInfo || marketInfo.isDisabled) {
            return {
                usdOut: 0n,
            };
        }
        const swapStats = (0, swapStats_1.getSwapStats)({
            marketInfo,
            usdIn,
            tokenInAddress: e.from,
            tokenOutAddress: e.to,
            shouldApplyPriceImpact: true,
            isAtomicSwap,
        });
        const isOutLiquidity = swapStats?.isOutLiquidity;
        const isOutCapacity = swapStats?.isOutCapacity;
        const usdOut = swapStats?.usdOut;
        if (usdOut === undefined || isOutLiquidity || isOutCapacity) {
            return {
                usdOut: 0n,
            };
        }
        return {
            usdOut,
        };
    };
};
exports.createSwapEstimator = createSwapEstimator;
const createMarketEdgeLiquidityGetter = (marketsInfoData) => {
    return (e) => {
        const marketInfo = (0, objects_1.getByKey)(marketsInfoData, e.marketAddress);
        if (!marketInfo || marketInfo.isDisabled) {
            return 0n;
        }
        const isTokenOutLong = (0, markets_1.getTokenPoolType)(marketInfo, e.to) === "long";
        const liquidity = (0, markets_1.getAvailableUsdLiquidityForCollateral)(marketInfo, isTokenOutLong);
        return liquidity;
    };
};
exports.createMarketEdgeLiquidityGetter = createMarketEdgeLiquidityGetter;
const createNaiveSwapEstimator = (marketsInfoData, isAtomicSwap) => {
    return (e, usdIn) => {
        let marketInfo = marketsInfoData[e.marketAddress];
        if (marketInfo === undefined || marketInfo.isDisabled) {
            return { swapYield: 0 };
        }
        const swapStats = (0, swapStats_1.getSwapStats)({
            marketInfo,
            usdIn,
            tokenInAddress: e.from,
            tokenOutAddress: e.to,
            shouldApplyPriceImpact: true,
            isAtomicSwap,
        });
        const usdOut = swapStats?.usdOut;
        if (usdOut === undefined || usdOut === 0n || swapStats.isOutCapacity || swapStats.isOutLiquidity) {
            return { swapYield: 0 };
        }
        const swapYield = (0, numbers_1.bigintToNumber)((usdOut * numbers_1.PRECISION) / usdIn, numbers_1.PRECISION_DECIMALS);
        return { swapYield };
    };
};
exports.createNaiveSwapEstimator = createNaiveSwapEstimator;
const createNaiveNetworkEstimator = ({ gasLimits, tokensData, gasPrice, chainId, }) => {
    return (usdIn, swapsCount) => {
        const estimatedGas = (0, getNaiveEstimatedGasBySwapCount_1.getNaiveEstimatedGasBySwapCount)(gasLimits.singleSwap, swapsCount);
        if (estimatedGas === null || estimatedGas === undefined)
            return { networkYield: 1.0, usdOut: usdIn };
        const oraclePriceCount = (0, fees_1.estimateOrderOraclePriceCount)(swapsCount);
        const feeUsd = (0, fees_1.getExecutionFee)(chainId, gasLimits, tokensData, estimatedGas, gasPrice, oraclePriceCount)?.feeUsd;
        if (feeUsd === undefined)
            return { networkYield: 1.0, usdOut: usdIn };
        const networkYield = (0, numbers_1.bigintToNumber)(bigmath_1.bigMath.mulDiv(usdIn, numbers_1.PRECISION, usdIn + feeUsd), numbers_1.PRECISION_DECIMALS);
        return { networkYield, usdOut: usdIn - feeUsd };
    };
};
exports.createNaiveNetworkEstimator = createNaiveNetworkEstimator;
function getBestSwapPath({ routes, usdIn, estimator, networkEstimator, }) {
    if (routes.length === 0) {
        return undefined;
    }
    let bestRoute = routes[0];
    let bestUsdOut = 0n;
    for (const route of routes) {
        try {
            let pathUsdOut = route.reduce((prevUsdOut, edge) => {
                const { usdOut } = estimator(edge, prevUsdOut);
                return usdOut;
            }, usdIn);
            if (networkEstimator) {
                const { usdOut } = networkEstimator(pathUsdOut, route.length);
                pathUsdOut = usdOut;
            }
            if (pathUsdOut > bestUsdOut) {
                bestRoute = route;
                bestUsdOut = pathUsdOut;
            }
        }
        catch (e) {
            continue;
        }
    }
    return bestRoute;
}
exports.getBestSwapPath = getBestSwapPath;
function getNaiveBestMarketSwapPathsFromTokenSwapPaths({ graph, tokenSwapPaths, usdIn, tokenInAddress, tokenOutAddress, estimator, topPathsCount = constants_1.DEFAULT_NAIVE_TOP_PATHS_COUNT, networkEstimator, }) {
    // This seems to be true, because for any path if we have performed swaps to and from token
    // The best markets sequence is the same
    const cachedBestMarketForTokenEdge = {};
    const calculatedCache = {};
    const topPaths = [];
    const networkYieldCache = {};
    for (const pathType of tokenSwapPaths) {
        const marketPath = [];
        let pathTypeSwapYield = 1;
        let bad = false;
        // Just how many times we have swapped from token A to token B
        const tokenSwapCounter = {};
        for (let hopIndex = 0; hopIndex <= pathType.length; hopIndex++) {
            const tokenHopFromAddress = hopIndex === 0 ? tokenInAddress : pathType[hopIndex - 1];
            const tokenHopToAddress = hopIndex === pathType.length ? tokenOutAddress : pathType[hopIndex];
            // prevTokenAddress -> tokenAddress
            // get all markets for prevTokenAddress -> tokenAddress
            const marketAddresses = getMarketsForTokenPair(graph, tokenHopFromAddress, tokenHopToAddress);
            if (marketAddresses.length === 0) {
                bad = true;
                break;
            }
            const tokenSwapCount = tokenSwapCounter[tokenHopFromAddress]?.[tokenHopToAddress] || 0;
            const key = `${tokenHopFromAddress}-${tokenHopToAddress}-${tokenSwapCount}`;
            let bestMarketInfo = cachedBestMarketForTokenEdge[key];
            if (!bestMarketInfo) {
                calculatedCache[tokenHopFromAddress] = calculatedCache[tokenHopFromAddress] || {};
                calculatedCache[tokenHopFromAddress][tokenHopToAddress] =
                    calculatedCache[tokenHopFromAddress][tokenHopToAddress] || {};
                bestMarketInfo = getBestMarketForTokenEdge({
                    marketAddresses,
                    usdIn,
                    tokenInAddress: tokenHopFromAddress,
                    tokenOutAddress: tokenHopToAddress,
                    estimator,
                    marketPath,
                    calculatedCache: calculatedCache[tokenHopFromAddress][tokenHopToAddress],
                });
                if (!bestMarketInfo) {
                    bad = true;
                    break;
                }
                cachedBestMarketForTokenEdge[key] = bestMarketInfo;
            }
            if (bestMarketInfo.swapYield === 0) {
                bad = true;
                break;
            }
            pathTypeSwapYield *= bestMarketInfo.swapYield;
            marketPath.push(bestMarketInfo.marketAddress);
            tokenSwapCounter[tokenHopFromAddress] = tokenSwapCounter[tokenHopFromAddress] || {};
            tokenSwapCounter[tokenHopFromAddress][tokenHopToAddress] =
                (tokenSwapCounter[tokenHopFromAddress][tokenHopToAddress] || 0) + 1;
        }
        if (bad) {
            continue;
        }
        if (topPaths.length < topPathsCount) {
            topPaths.push({ marketPath: marketPath, swapYield: pathTypeSwapYield });
        }
        else {
            let adjustedPathTypeSwapYield = pathTypeSwapYield;
            if (networkEstimator) {
                let networkYield = networkYieldCache[marketPath.length];
                if (networkYield === undefined) {
                    networkYield = networkEstimator(usdIn, marketPath.length).networkYield;
                    networkYieldCache[marketPath.length] = networkYield;
                }
                adjustedPathTypeSwapYield = adjustedPathTypeSwapYield * networkYield;
            }
            //  if yield is greater than any of the top paths, replace the one with the lowest yield
            let minSwapYield = topPaths[0].swapYield;
            let minSwapYieldIndex = 0;
            for (let i = 1; i < topPaths.length; i++) {
                if (topPaths[i].swapYield < minSwapYield) {
                    minSwapYield = topPaths[i].swapYield;
                    minSwapYieldIndex = i;
                }
            }
            if (adjustedPathTypeSwapYield > minSwapYield) {
                topPaths[minSwapYieldIndex] = { marketPath: marketPath, swapYield: adjustedPathTypeSwapYield };
            }
        }
    }
    return topPaths.map((p) => p.marketPath);
}
exports.getNaiveBestMarketSwapPathsFromTokenSwapPaths = getNaiveBestMarketSwapPathsFromTokenSwapPaths;
function getMarketsForTokenPair(graph, tokenAAddress, tokenBAddress) {
    if (graph[tokenAAddress]?.[tokenBAddress]) {
        return graph[tokenAAddress][tokenBAddress];
    }
    if (graph[tokenBAddress]?.[tokenAAddress]) {
        return graph[tokenBAddress][tokenAAddress];
    }
    return [];
}
exports.getMarketsForTokenPair = getMarketsForTokenPair;
function getBestMarketForTokenEdge({ marketAddresses, usdIn, tokenInAddress, tokenOutAddress, estimator, marketPath, calculatedCache, }) {
    let bestMarketAddress = marketAddresses[0];
    let bestYield = 0;
    let found = false;
    for (const marketAddress of marketAddresses) {
        if (marketPath && marketPath.includes(marketAddress)) {
            continue;
        }
        let swapYield = undefined;
        const key = marketAddress;
        if (calculatedCache) {
            swapYield = calculatedCache[key];
        }
        if (swapYield === undefined) {
            swapYield = estimator({
                marketAddress,
                from: tokenInAddress,
                to: tokenOutAddress,
            }, usdIn).swapYield;
            if (calculatedCache) {
                calculatedCache[key] = swapYield;
            }
        }
        if (swapYield > bestYield) {
            bestYield = swapYield;
            bestMarketAddress = marketAddress;
            found = true;
        }
    }
    if (!found) {
        return undefined;
    }
    return {
        marketAddress: bestMarketAddress,
        swapYield: bestYield,
    };
}
exports.getBestMarketForTokenEdge = getBestMarketForTokenEdge;
function marketRouteToMarketEdges(marketPath, from, marketsInfoData) {
    let edges = [];
    for (let i = 0; i < marketPath.length; i++) {
        const currentFrom = i === 0 ? from : edges[i - 1].to;
        const currentTo = marketsInfoData[marketPath[i]].longTokenAddress === currentFrom
            ? marketsInfoData[marketPath[i]].shortTokenAddress
            : marketsInfoData[marketPath[i]].longTokenAddress;
        edges.push({ from: currentFrom, to: currentTo, marketAddress: marketPath[i] });
    }
    return edges;
}
exports.marketRouteToMarketEdges = marketRouteToMarketEdges;
function getTokenSwapPathsForTokenPair(tokenSwapPaths, tokenAAddress, tokenBAddress) {
    if (tokenSwapPaths[tokenAAddress]?.[tokenBAddress]) {
        return tokenSwapPaths[tokenAAddress][tokenBAddress];
    }
    if (tokenSwapPaths[tokenBAddress]?.[tokenAAddress]) {
        return tokenSwapPaths[tokenBAddress][tokenAAddress].map((route) => [...route].reverse());
    }
    return [];
}
exports.getTokenSwapPathsForTokenPair = getTokenSwapPathsForTokenPair;
function getTokenSwapPathsForTokenPairPrebuilt(chainId, from, to) {
    return getTokenSwapPathsForTokenPair(preparedSwapData_1.TOKEN_SWAP_PATHS[chainId], from, to);
}
exports.getTokenSwapPathsForTokenPairPrebuilt = getTokenSwapPathsForTokenPairPrebuilt;
function getMarketAdjacencyGraph(chainId) {
    return preparedSwapData_1.MARKETS_ADJACENCY_GRAPH[chainId];
}
exports.getMarketAdjacencyGraph = getMarketAdjacencyGraph;
function findAllReachableTokens(chainId, from) {
    return preparedSwapData_1.REACHABLE_TOKENS[chainId][from];
}
exports.findAllReachableTokens = findAllReachableTokens;
function getMaxLiquidityMarketSwapPathFromTokenSwapPaths({ graph, tokenSwapPaths, tokenInAddress, tokenOutAddress, getLiquidity, }) {
    // go through all edges and find best yield market for it
    const cachedMaxLiquidityMarketForTokenEdge = {};
    let bestMarketPath = undefined;
    let bestLiquidity = 0n;
    for (const pathType of tokenSwapPaths) {
        let bad = false;
        let bestMarketPathForPathType = [];
        let pathTypeBestLiquidity = viem_1.maxUint256;
        for (let hopIndex = 0; hopIndex <= pathType.length; hopIndex++) {
            const tokenFromAddress = hopIndex === 0 ? tokenInAddress : pathType[hopIndex - 1];
            const tokenToAddress = hopIndex === pathType.length ? tokenOutAddress : pathType[hopIndex];
            // prevTokenAddress -> tokenAddress
            // get all markets for prevTokenAddress -> tokenAddress
            const markets = getMarketsForTokenPair(graph, tokenFromAddress, tokenToAddress);
            if (markets.length === 0) {
                bad = true;
                break;
            }
            let bestMarketInfo = cachedMaxLiquidityMarketForTokenEdge[tokenFromAddress]?.[tokenToAddress];
            if (!bestMarketInfo) {
                bestMarketInfo = getMaxLiquidityMarketForTokenEdge({
                    markets,
                    tokenInAddress,
                    tokenOutAddress,
                    getLiquidity,
                });
                cachedMaxLiquidityMarketForTokenEdge[tokenFromAddress] =
                    cachedMaxLiquidityMarketForTokenEdge[tokenFromAddress] || {};
                cachedMaxLiquidityMarketForTokenEdge[tokenFromAddress][tokenToAddress] = bestMarketInfo;
            }
            bestMarketPathForPathType.push(bestMarketInfo.marketAddress);
            if (bestMarketInfo.liquidity < pathTypeBestLiquidity) {
                pathTypeBestLiquidity = bestMarketInfo.liquidity;
            }
            if (pathTypeBestLiquidity < bestLiquidity) {
                bad = true;
                break;
            }
        }
        if (bad) {
            continue;
        }
        if (pathTypeBestLiquidity > bestLiquidity) {
            bestLiquidity = pathTypeBestLiquidity;
            bestMarketPath = bestMarketPathForPathType;
        }
    }
    return bestMarketPath ? { path: bestMarketPath, liquidity: bestLiquidity } : undefined;
}
exports.getMaxLiquidityMarketSwapPathFromTokenSwapPaths = getMaxLiquidityMarketSwapPathFromTokenSwapPaths;
function getMaxLiquidityMarketForTokenEdge({ markets, tokenInAddress, tokenOutAddress, getLiquidity, }) {
    let bestMarketAddress = markets[0];
    let bestLiquidity = 0n;
    for (const market of markets) {
        const liquidity = getLiquidity({
            marketAddress: market,
            from: tokenInAddress,
            to: tokenOutAddress,
        });
        if (liquidity > bestLiquidity) {
            bestLiquidity = liquidity;
            bestMarketAddress = market;
        }
    }
    return {
        marketAddress: bestMarketAddress,
        liquidity: bestLiquidity,
    };
}
exports.getMaxLiquidityMarketForTokenEdge = getMaxLiquidityMarketForTokenEdge;
