import { getExcessiveExecutionFee, getHighExecutionFee, MIN_EXECUTION_FEE_USD } from "../../configs/chains";
import { USD_DECIMALS } from "../../configs/factors";
import { NATIVE_TOKEN_ADDRESS } from "../../configs/tokens";
import { DecreasePositionSwapType } from "../../types/orders";
import { bigMath } from "../bigmath";
import { applyFactor, expandDecimals } from "../numbers";
import { convertBetweenTokens, convertToTokenAmount, convertToUsd, getTokenData } from "../tokens";
export function getExecutionFee(chainId, gasLimits, 
// TODO optimize we only need the native token data
tokensData, estimatedGasLimit, gasPrice, oraclePriceCount, numberOfParts) {
    const nativeToken = getTokenData(tokensData, NATIVE_TOKEN_ADDRESS);
    if (!nativeToken)
        return undefined;
    // #region adjustGasLimitForEstimate. Copy from contract.
    let baseGasLimit = gasLimits.estimatedGasFeeBaseAmount;
    baseGasLimit += gasLimits.estimatedGasFeePerOraclePrice * oraclePriceCount;
    const multiplierFactor = gasLimits.estimatedFeeMultiplierFactor;
    const gasLimit = baseGasLimit + applyFactor(estimatedGasLimit, multiplierFactor);
    // #endregion
    // avoid botanix gas spikes when chain is not actively used
    const minGasCostUsd = MIN_EXECUTION_FEE_USD[chainId];
    const minGasCost = convertToTokenAmount(minGasCostUsd, nativeToken.decimals, nativeToken.prices.minPrice);
    let feeTokenAmountPerExecution = gasLimit * gasPrice;
    if (minGasCost) {
        feeTokenAmountPerExecution = bigMath.max(feeTokenAmountPerExecution, minGasCost);
    }
    const feeTokenAmount = feeTokenAmountPerExecution * BigInt(numberOfParts ?? 1);
    const feeUsd = convertToUsd(feeTokenAmount, nativeToken.decimals, nativeToken.prices.minPrice);
    const isFeeHigh = feeUsd > expandDecimals(getHighExecutionFee(chainId), USD_DECIMALS);
    const isFeeVeryHigh = feeUsd > expandDecimals(getExcessiveExecutionFee(chainId), USD_DECIMALS);
    return {
        feeUsd,
        feeTokenAmount,
        feeToken: nativeToken,
        gasLimit,
        isFeeHigh,
        isFeeVeryHigh,
    };
}
export function estimateRelayerGasLimit({ gasLimits, tokenPermitsCount, feeSwapsCount, feeExternalCallsGasLimit, oraclePriceCount, transactionPayloadGasLimit, l1GasLimit, }) {
    const feeSwapsGasLimit = gasLimits.singleSwap * BigInt(feeSwapsCount);
    const oraclePricesGasLimit = gasLimits.estimatedGasFeePerOraclePrice * BigInt(oraclePriceCount);
    const tokenPermitsGasLimit = gasLimits.tokenPermitGasLimit * BigInt(tokenPermitsCount);
    const relayParamsGasLimit = feeSwapsGasLimit + oraclePricesGasLimit + tokenPermitsGasLimit + feeExternalCallsGasLimit;
    return relayParamsGasLimit + transactionPayloadGasLimit + l1GasLimit;
}
export function approximateL1GasBuffer({ l1Reference, sizeOfData, }) {
    const evaluated = Math.round((Number(l1Reference.gasLimit) * Math.log(Number(sizeOfData))) / Math.log(Number(l1Reference.sizeOfData)));
    const l1GasLimit = Math.abs(evaluated) < Infinity ? BigInt(evaluated) : l1Reference.gasLimit;
    return l1GasLimit;
}
export function estimateBatchGasLimit({ gasLimits, createOrdersCount, updateOrdersCount, cancelOrdersCount, externalCallsGasLimit, isGmxAccount, }) {
    const createOrdersGasLimit = gasLimits.createOrderGasLimit * BigInt(createOrdersCount);
    const updateOrdersGasLimit = gasLimits.updateOrderGasLimit * BigInt(updateOrdersCount);
    const cancelOrdersGasLimit = gasLimits.cancelOrderGasLimit * BigInt(cancelOrdersCount);
    const gmxAccountOverhead = isGmxAccount ? gasLimits.gmxAccountCollateralGasLimit : 0n;
    return (createOrdersGasLimit + updateOrdersGasLimit + cancelOrdersGasLimit + externalCallsGasLimit + gmxAccountOverhead);
}
export function estimateBatchMinGasPaymentTokenAmount({ chainId, gasPaymentToken, isGmxAccount, relayFeeToken, gasPrice, gasLimits, l1Reference, tokensData, createOrdersCount = 1, updateOrdersCount = 0, cancelOrdersCount = 0, executionFeeAmount, }) {
    const batchGasLimit = estimateBatchGasLimit({
        gasLimits,
        createOrdersCount,
        updateOrdersCount,
        cancelOrdersCount,
        externalCallsGasLimit: 0n,
        isGmxAccount,
    });
    const relayerGasLimit = estimateRelayerGasLimit({
        gasLimits,
        tokenPermitsCount: 0,
        feeSwapsCount: relayFeeToken.address === gasPaymentToken.address ? 0 : 1,
        feeExternalCallsGasLimit: 0n,
        oraclePriceCount: 2,
        transactionPayloadGasLimit: batchGasLimit,
        l1GasLimit: l1Reference?.gasLimit ?? 0n,
    });
    const gasLimit = relayerGasLimit + batchGasLimit;
    const feeAmount = gasLimit * gasPrice;
    const executionGasLimit = estimateExecuteIncreaseOrderGasLimit(gasLimits, {
        swapsCount: 2,
        callbackGasLimit: 0n,
    });
    const executionFee = executionFeeAmount ??
        getExecutionFee(chainId, gasLimits, tokensData, executionGasLimit, gasPrice, 4n)?.feeTokenAmount;
    let totalFee = feeAmount + (executionFee ?? 0n);
    const minGasPaymentTokenBalance = convertBetweenTokens(totalFee, relayFeeToken, gasPaymentToken, false);
    return minGasPaymentTokenBalance;
}
/**
 * Copy from contract: `estimateExecuteIncreaseOrderGasLimit`
 */
export function estimateExecuteIncreaseOrderGasLimit(gasLimits, order) {
    const gasPerSwap = gasLimits.singleSwap;
    const swapsCount = BigInt(order.swapsCount ?? 0);
    return gasLimits.increaseOrder + gasPerSwap * swapsCount + (order.callbackGasLimit ?? 0n);
}
/**
 * Copy from contract: `estimateExecuteDecreaseOrderGasLimit`
 */
export function estimateExecuteDecreaseOrderGasLimit(gasLimits, order) {
    const gasPerSwap = gasLimits.singleSwap;
    let swapsCount = BigInt(order.swapsCount);
    if (order.decreaseSwapType !== DecreasePositionSwapType.NoSwap) {
        swapsCount += 1n;
    }
    return gasLimits.decreaseOrder + gasPerSwap * swapsCount + (order.callbackGasLimit ?? 0n);
}
export function estimateExecuteSwapOrderGasLimit(gasLimits, order) {
    const gasPerSwap = gasLimits.singleSwap;
    const swapsCount = BigInt(order.swapsCount);
    return gasLimits.swapOrder + gasPerSwap * swapsCount + (order.callbackGasLimit ?? 0n);
}
/**
 * Only GM deposits. Do not confuse with increase with zero delta size.
 *
 * Copy from contract: `estimateExecuteDepositGasLimit`
 */
export function estimateExecuteDepositGasLimit(gasLimits, deposit) {
    const gasPerSwap = gasLimits.singleSwap;
    const swapsCount = BigInt((deposit.longTokenSwapsCount ?? 0) + (deposit.shortTokenSwapsCount ?? 0));
    const gasForSwaps = swapsCount * gasPerSwap;
    return gasLimits.depositToken + (deposit.callbackGasLimit ?? 0n) + gasForSwaps;
}
export function estimateExecuteGlvDepositGasLimit(gasLimits, { marketsCount, isMarketTokenDeposit, }) {
    const gasPerGlvPerMarket = gasLimits.glvPerMarketGasLimit;
    const gasForGlvMarkets = gasPerGlvPerMarket * marketsCount;
    const glvDepositGasLimit = gasLimits.glvDepositGasLimit;
    const gasLimit = glvDepositGasLimit + gasForGlvMarkets;
    if (isMarketTokenDeposit) {
        return gasLimit;
    }
    return gasLimit + gasLimits.depositToken;
}
export function estimateExecuteGlvWithdrawalGasLimit(gasLimits, { marketsCount, }) {
    const gasPerGlvPerMarket = gasLimits.glvPerMarketGasLimit;
    const gasForGlvMarkets = gasPerGlvPerMarket * marketsCount;
    const glvWithdrawalGasLimit = gasLimits.glvWithdrawalGasLimit;
    const gasLimit = glvWithdrawalGasLimit + gasForGlvMarkets;
    return gasLimit + gasLimits.withdrawalMultiToken;
}
/**
 * Only GM withdrawals. Do not confuse with decrease with zero delta size.
 *
 * Copy from contract: `estimateExecuteWithdrawalGasLimit`
 */
export function estimateExecuteWithdrawalGasLimit(gasLimits, withdrawal) {
    // Swap is not used but supported in the contract.
    // const gasPerSwap = gasLimits.singleSwap;
    // const swapsCount = 0n;
    // const gasForSwaps = swapsCount * gasPerSwap;
    return gasLimits.withdrawalMultiToken + (withdrawal.callbackGasLimit ?? 0n);
}
/**
 * Copy from contract: `estimateExecuteShiftGasLimit`
 */
export function estimateExecuteShiftGasLimit(gasLimits, shift) {
    return gasLimits.shift + (shift.callbackGasLimit ?? 0n);
}
