export class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
    }
    has(key) {
        return this.cache.has(key);
    }
    get(key) {
        if (this.cache.has(key)) {
            // Move to end (most recently used) by deleting and re-inserting
            const value = this.cache.get(key);
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        }
        return undefined;
    }
    set(key, value) {
        if (typeof key !== "string") {
            throw new Error("Key must be a string");
        }
        if (this.cache.has(key)) {
            // Update existing key: delete and re-insert to move to end (most recently used)
            this.cache.delete(key);
            this.cache.set(key, value);
        }
        else {
            // If capacity is 0, don't store anything
            if (this.capacity === 0) {
                return;
            }
            // If capacity is reached, remove least recently used (first entry)
            if (this.cache.size === this.capacity) {
                const firstKey = this.cache.keys().next().value;
                if (firstKey !== undefined) {
                    this.cache.delete(firstKey);
                }
            }
            // Add the new key-value pair (inserted at end = most recently used)
            this.cache.set(key, value);
        }
    }
    delete(key) {
        this.cache.delete(key);
    }
    getKeys() {
        return Array.from(this.cache.keys());
    }
    clean() {
        this.cache.clear();
    }
}
