import concat from "lodash/concat";
import { encodeFunctionData, zeroAddress, zeroHash } from "viem";
import { abis } from "../../../abis";
import { getContract } from "../../../configs/contracts";
import { convertTokenAddress, NATIVE_TOKEN_ADDRESS } from "../../../configs/tokens";
import { DecreasePositionSwapType } from "../../../types/orders";
import { isMarketOrderType } from "../../../utils/orders";
import { simulateExecuteOrder } from "../../../utils/simulateExecuteOrder";
import { convertToContractPrice } from "../../../utils/tokens";
import { applySlippageToMinOut, applySlippageToPrice } from "../../../utils/trade";
import { createCancelEncodedPayload } from "./cancelOrdersTxn";
import { createDecreaseEncodedPayload } from "./createDecreaseOrderTxn";
import { createUpdateEncodedPayload } from "./updateOrderTxn";
export async function createIncreaseOrderTxn({ sdk, createIncreaseOrderParams: p, createDecreaseOrderParams, cancelOrderParams, updateOrderParams, }) {
    const isNativePayment = p.initialCollateralAddress === NATIVE_TOKEN_ADDRESS;
    const chainId = sdk.chainId;
    const exchangeRouter = getContract(chainId, "ExchangeRouter");
    const orderVaultAddress = getContract(chainId, "OrderVault");
    const wntCollateralAmount = isNativePayment ? p.initialCollateralAmount : 0n;
    const initialCollateralTokenAddress = convertTokenAddress(chainId, p.initialCollateralAddress, "wrapped");
    const shouldApplySlippage = isMarketOrderType(p.orderType);
    const acceptablePrice = shouldApplySlippage
        ? applySlippageToPrice(p.allowedSlippage, p.acceptablePrice, true, p.isLong)
        : p.acceptablePrice;
    const wntAmountToIncrease = wntCollateralAmount + p.executionFee;
    const totalWntAmount = concat(createDecreaseOrderParams, updateOrderParams).reduce((acc, p) => (p ? acc + p.executionFee : acc), wntAmountToIncrease);
    const encodedPayload = await createEncodedPayload({
        routerAbi: abis.ExchangeRouter,
        orderVaultAddress,
        totalWntAmount: wntAmountToIncrease,
        p,
        acceptablePrice,
        isNativePayment,
        initialCollateralTokenAddress,
        uiFeeReceiver: sdk.config.settings?.uiFeeReceiverAccount,
    });
    const simulationEncodedPayload = await createEncodedPayload({
        routerAbi: abis.ExchangeRouter,
        orderVaultAddress,
        totalWntAmount: wntAmountToIncrease,
        p,
        acceptablePrice,
        isNativePayment,
        initialCollateralTokenAddress,
        uiFeeReceiver: sdk.config.settings?.uiFeeReceiverAccount,
    });
    const decreaseEncodedPayload = createDecreaseEncodedPayload({
        sdk,
        orderVaultAddress,
        ps: createDecreaseOrderParams || [],
    });
    const cancelEncodedPayload = createCancelEncodedPayload(cancelOrderParams?.map(({ orderKey }) => orderKey) || []);
    const updateEncodedPayload = updateOrderParams?.reduce((acc, { orderKey, sizeDeltaUsd, executionFee, indexToken, acceptablePrice, triggerPrice, minOutputAmount, autoCancel }) => {
        return [
            ...acc,
            ...createUpdateEncodedPayload({
                sdk,
                orderKey,
                sizeDeltaUsd,
                executionFee,
                indexToken,
                acceptablePrice,
                triggerPrice,
                minOutputAmount,
                autoCancel,
            }),
        ];
    }, []) ?? [];
    const primaryPriceOverrides = {};
    if (p.triggerPrice != undefined) {
        primaryPriceOverrides[p.indexToken.address] = {
            minPrice: p.triggerPrice,
            maxPrice: p.triggerPrice,
        };
    }
    if (!p.skipSimulation) {
        await simulateExecuteOrder(sdk, {
            tokensData: p.tokensData,
            primaryPriceOverrides,
            createMulticallPayload: simulationEncodedPayload,
            value: totalWntAmount,
        });
    }
    const finalPayload = [...encodedPayload, ...decreaseEncodedPayload, ...cancelEncodedPayload, ...updateEncodedPayload];
    await sdk.callContract(exchangeRouter, abis.ExchangeRouter, "multicall", [finalPayload], {
        value: totalWntAmount,
    });
}
async function createEncodedPayload({ routerAbi, orderVaultAddress, totalWntAmount, p, acceptablePrice, isNativePayment, initialCollateralTokenAddress, uiFeeReceiver, }) {
    const orderParams = createOrderParams({
        p,
        acceptablePrice,
        initialCollateralTokenAddress,
        isNativePayment,
        uiFeeReceiver,
    });
    const multicall = [
        { method: "sendWnt", params: [orderVaultAddress, totalWntAmount] },
        !isNativePayment
            ? { method: "sendTokens", params: [p.initialCollateralAddress, orderVaultAddress, p.initialCollateralAmount] }
            : undefined,
        {
            method: "createOrder",
            params: [orderParams],
        },
    ];
    return multicall.filter(Boolean).map((call) => encodeFunctionData({
        abi: routerAbi,
        functionName: call.method,
        args: call.params,
    }));
}
function createOrderParams({ p, acceptablePrice, initialCollateralTokenAddress, isNativePayment, uiFeeReceiver, }) {
    return {
        addresses: {
            cancellationReceiver: zeroAddress,
            receiver: p.account,
            initialCollateralToken: initialCollateralTokenAddress,
            callbackContract: zeroAddress,
            market: p.marketAddress,
            swapPath: p.swapPath,
            uiFeeReceiver: uiFeeReceiver || zeroAddress,
        },
        numbers: {
            sizeDeltaUsd: p.sizeDeltaUsd,
            initialCollateralDeltaAmount: 0n,
            triggerPrice: convertToContractPrice(p.triggerPrice ?? 0n, p.indexToken.decimals),
            acceptablePrice: convertToContractPrice(acceptablePrice, p.indexToken.decimals),
            executionFee: p.executionFee,
            callbackGasLimit: 0n,
            minOutputAmount: 0n,
            validFromTime: 0n,
        },
        orderType: p.orderType,
        decreasePositionSwapType: DecreasePositionSwapType.NoSwap,
        isLong: p.isLong,
        shouldUnwrapNativeToken: isNativePayment,
        autoCancel: false,
        referralCode: p.referralCode || zeroHash,
        dataList: p.dataList ?? [],
    };
}
export function getPendingOrderFromParams(chainId, txnType, p) {
    const isNativeReceive = p.receiveTokenAddress === NATIVE_TOKEN_ADDRESS;
    const shouldApplySlippage = isMarketOrderType(p.orderType);
    let minOutputAmount = 0n;
    if ("minOutputUsd" in p) {
        // eslint-disable-next-line
        shouldApplySlippage ? applySlippageToMinOut(p.allowedSlippage, p.minOutputUsd) : p.minOutputUsd;
    }
    if ("minOutputAmount" in p) {
        minOutputAmount = p.minOutputAmount;
    }
    const initialCollateralTokenAddress = convertTokenAddress(chainId, p.initialCollateralAddress, "wrapped");
    const orderKey = "orderKey" in p && p.orderKey ? p.orderKey : undefined;
    return {
        txnType,
        account: p.account,
        marketAddress: p.marketAddress,
        initialCollateralTokenAddress,
        initialCollateralDeltaAmount: p.initialCollateralDeltaAmount,
        swapPath: p.swapPath,
        sizeDeltaUsd: p.sizeDeltaUsd,
        minOutputAmount: minOutputAmount,
        isLong: p.isLong,
        orderType: p.orderType,
        shouldUnwrapNativeToken: isNativeReceive,
        orderKey,
    };
}
