import { isAddressEqual } from "viem";
import { getContract } from "../../configs/contracts";
import { accountOrderListKey } from "../../configs/dataStore";
import { getWrappedToken } from "../../configs/tokens";
import { estimateOrderOraclePriceCount } from "../../utils/fees/estimateOraclePriceCount";
import { estimateExecuteDecreaseOrderGasLimit, getExecutionFee } from "../../utils/fees/executionFee";
import { isIncreaseOrderType, isLimitOrderType, isSwapOrderType, isTriggerDecreaseOrderType } from "../../utils/orders";
import { getSwapPathOutputAddresses } from "../../utils/swap/swapStats";
export const getOrderExecutionFee = (sdk, swapsCount, decreasePositionSwapType, gasLimits, tokensData, gasPrice) => {
    if (!gasLimits || !tokensData || gasPrice === undefined)
        return;
    const estimatedGas = estimateExecuteDecreaseOrderGasLimit(gasLimits, {
        decreaseSwapType: decreasePositionSwapType,
        swapsCount: swapsCount ?? 0,
    });
    const oraclePriceCount = estimateOrderOraclePriceCount(swapsCount);
    return getExecutionFee(sdk.chainId, gasLimits, tokensData, estimatedGas, gasPrice, oraclePriceCount);
};
export const getExecutionFeeAmountForEntry = (sdk, entry, gasLimits, tokensData, gasPrice) => {
    if (!entry.txnType || entry.txnType === "cancel")
        return undefined;
    const securedExecutionFee = entry.order?.executionFee ?? 0n;
    let swapsCount = 0;
    const executionFee = getOrderExecutionFee(sdk, swapsCount, entry.decreaseAmounts?.decreaseSwapType, gasLimits, tokensData, gasPrice);
    if (!executionFee || securedExecutionFee >= executionFee.feeTokenAmount)
        return undefined;
    return executionFee.feeTokenAmount - securedExecutionFee;
};
export function matchByMarket({ order, nonSwapRelevantDefinedFiltersLowercased, hasNonSwapRelevantDefinedMarkets, pureDirectionFilters, hasPureDirectionFilters, swapRelevantDefinedMarketsLowercased, hasSwapRelevantDefinedMarkets, marketsInfoData, chainId, }) {
    if (!hasNonSwapRelevantDefinedMarkets && !hasSwapRelevantDefinedMarkets && !hasPureDirectionFilters) {
        return true;
    }
    const isSwapOrder = isSwapOrderType(order.orderType);
    const matchesPureDirectionFilter = hasPureDirectionFilters &&
        (isSwapOrder
            ? pureDirectionFilters.includes("swap")
            : pureDirectionFilters.includes(order.isLong ? "long" : "short"));
    if (hasPureDirectionFilters && !matchesPureDirectionFilter) {
        return false;
    }
    if (!hasNonSwapRelevantDefinedMarkets && !hasSwapRelevantDefinedMarkets) {
        return true;
    }
    if (isSwapOrder) {
        const sourceMarketInSwapPath = swapRelevantDefinedMarketsLowercased.includes(order.swapPath.at(0).toLowerCase());
        const destinationMarketInSwapPath = swapRelevantDefinedMarketsLowercased.includes(order.swapPath.at(-1).toLowerCase());
        return sourceMarketInSwapPath || destinationMarketInSwapPath;
    }
    else if (!isSwapOrder) {
        return nonSwapRelevantDefinedFiltersLowercased.some((filter) => {
            const marketMatch = filter.marketAddress === "any" || filter.marketAddress === order.marketAddress.toLowerCase();
            const directionMath = filter.direction === "any" || filter.direction === (order.isLong ? "long" : "short");
            const initialCollateralAddress = order.initialCollateralTokenAddress.toLowerCase();
            let collateralMatch = true;
            if (!filter.collateralAddress) {
                collateralMatch = true;
            }
            else if (isLimitOrderType(order.orderType)) {
                const wrappedToken = getWrappedToken(chainId);
                if (!marketsInfoData) {
                    collateralMatch = true;
                }
                else {
                    const { outTokenAddress } = getSwapPathOutputAddresses({
                        marketsInfoData,
                        initialCollateralAddress,
                        isIncrease: isIncreaseOrderType(order.orderType),
                        shouldUnwrapNativeToken: order.shouldUnwrapNativeToken,
                        swapPath: order.swapPath,
                        wrappedNativeTokenAddress: wrappedToken.address,
                    });
                    collateralMatch =
                        outTokenAddress !== undefined && isAddressEqual(outTokenAddress, filter.collateralAddress);
                }
            }
            else if (isTriggerDecreaseOrderType(order.orderType)) {
                collateralMatch = isAddressEqual(order.initialCollateralTokenAddress, filter.collateralAddress);
            }
            return marketMatch && directionMath && collateralMatch;
        });
    }
    return false;
}
export const DEFAULT_COUNT = 1000;
export function buildGetOrdersMulticall(chainId, account) {
    return {
        dataStore: {
            contractAddress: getContract(chainId, "DataStore"),
            abiId: "DataStore",
            calls: {
                count: {
                    methodName: "getBytes32Count",
                    params: [accountOrderListKey(account)],
                },
                keys: {
                    methodName: "getBytes32ValuesAt",
                    params: [accountOrderListKey(account), 0, DEFAULT_COUNT],
                },
            },
        },
        reader: {
            contractAddress: getContract(chainId, "SyntheticsReader"),
            abiId: "SyntheticsReader",
            calls: {
                orders: {
                    methodName: "getAccountOrders",
                    params: [getContract(chainId, "DataStore"), account, 0, DEFAULT_COUNT],
                },
            },
        },
    };
}
export function parseGetOrdersResponse(res) {
    const count = Number(res.data.dataStore.count.returnValues[0]);
    const orderKeys = res.data.dataStore.keys.returnValues;
    const orders = res.data.reader.orders.returnValues;
    return {
        count,
        orders: orders.map(({ order }, i) => {
            const key = orderKeys[i];
            const orderData = {
                key,
                account: order.addresses.account,
                receiver: order.addresses.receiver,
                callbackContract: order.addresses.callbackContract,
                marketAddress: order.addresses.market,
                initialCollateralTokenAddress: order.addresses.initialCollateralToken,
                swapPath: order.addresses.swapPath,
                sizeDeltaUsd: BigInt(order.numbers.sizeDeltaUsd),
                initialCollateralDeltaAmount: BigInt(order.numbers.initialCollateralDeltaAmount),
                contractTriggerPrice: BigInt(order.numbers.triggerPrice),
                contractAcceptablePrice: BigInt(order.numbers.acceptablePrice),
                executionFee: BigInt(order.numbers.executionFee),
                callbackGasLimit: BigInt(order.numbers.callbackGasLimit),
                minOutputAmount: BigInt(order.numbers.minOutputAmount),
                updatedAtTime: BigInt(order.numbers.updatedAtTime),
                isLong: order.flags.isLong,
                shouldUnwrapNativeToken: order.flags.shouldUnwrapNativeToken,
                isFrozen: order.flags.isFrozen,
                orderType: Number(order.numbers.orderType),
                decreasePositionSwapType: Number(order.numbers.decreasePositionSwapType),
                autoCancel: order.flags.autoCancel,
                uiFeeReceiver: order.addresses.uiFeeReceiver,
                validFromTime: BigInt(order.numbers.validFromTime),
                data: order._dataList,
            };
            return orderData;
        }),
    };
}
